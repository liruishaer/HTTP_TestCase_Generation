[.* MUST .*]	
 An implementation is not compliant if it fails to satisfy one or more of the MUST or REQUIRED level requirements for the protocols it implements.



[.* SHOULD .*]	[.* MUST .*]	
An implementation that satisfies all the MUST or REQUIRED level and all the SHOULD level requirements for its protocols is said to be "unconditionally compliant"; one that satisfies all the MUST level requirements but not all the SHOULD level requirements for its protocols is said to be "conditionally compliant."



[.* MUST .*]	
A proxy MUST implement both the client and server requirements of this specification.



[.* MUST .*]	
Therefore, where at least one element is required, at least one non-null element MUST be present.



[.* MUST .*]	
 separators) MUST exist between any two tokens (for the definition of "token" below), since they would otherwise be interpreted as a single token.



[.* MAY .*]	
A recipient MAY replace any linear white space with a single SP before interpreting the field value or forwarding the message downstream.



[.* MAY .*]	
Words of *TEXT MAY contain characters from character sets other than ISO- 8859-1 [22] only when encoded according to the rules of RFC 2047 [14].



[.* MUST .*]	
These special characters MUST be in a quoted string to be used within a parameter value (as defined in section 3.6).



[.* MAY .*]	
 The backslash character ("\") MAY be used as a single-character quoting mechanism only within quoted-string and comment constructs.



[.* MUST .*]	[.* MAY .*]	
 Note that the major and minor numbers MUST be treated as separate integers and that each MAY be incremented higher than a single digit.



[.* MUST .*]	
Leading zeros MUST be ignored by recipients and MUST NOT be sent.



[.* MUST .*]	
 An application that sends a request or response message that includes HTTP-Version of "HTTP/1.1" MUST be at least conditionally compliant with this specification.



[.* SHOULD .*]	[.* MUST .*]	
Applications that are at least conditionally compliant with this specification SHOULD use an HTTP-Version of "HTTP/1.1" in their messages, and MUST do so for any message that is not compatible with HTTP/1.0.



[.* MUST .*]	
Since the protocol version indicates the protocol capability of the sender, a proxy/gateway MUST NOT send a message with a version indicator which is greater than its actual version.



[.* MUST .*]	
If a higher version request is received, the proxy/gateway MUST either downgrade the request version, or respond with an error, or switch to tunnel behavior.



[.* MUST .*]	
 Due to interoperability problems with HTTP/1.0 proxies discovered since the publication of RFC 2068[33], caching proxies MUST, gateways MAY, and tunnels MUST NOT upgrade the request to the highest version they support.



[.* MUST .*]	
The proxy/gateway's response to that request MUST be in the same major version as the request.



[.* SHOULD .*]	[.* MUST .*]	
Servers MUST be able to handle the URI of any resource they serve, and SHOULD be able to handle URIs of unbounded length if they provide GET-based forms that could generate such URIs.



[.* SHOULD .*]	
A server SHOULD return 414 (Request-URI Too Long) status if a URI is longer than the server can handle (see section 10.4.15).



[.* SHOULD .*]	
The use of IP addresses in URLs SHOULD be avoided whenever possible (see RFC 1900 [24]).



[.* MUST .*]	
If the abs_path is not present in the URL, it MUST be given as "/" when used as a Request-URI for a resource (section 5.1.2).



[.* MAY .*]	
If a proxy receives a host name which is not a fully qualified domain name, it MAY add its domain to the host name it received.



[.* MUST .*]	
If a proxy receives a fully qualified domain name, the proxy MUST NOT change the host name.



[.* SHOULD .*]	
 When comparing two URIs to decide if they match or not, a client SHOULD use a case-sensitive octet-by-octet comparison of the entire URIs, with these exceptions:



[.* MUST .*]	
 - Comparisons of host names MUST be case-insensitive;



[.* MUST .*]	
 - Comparisons of scheme names MUST be case-insensitive;



[.* MUST .*]	
HTTP/1.1 clients and servers that parse the date value MUST accept all three formats (for compatibility with HTTP/1.0), though they MUST only generate the RFC 1123 format for representing HTTP-date values in header fields.



[.* MUST .*]	
All HTTP date/time stamps MUST be represented in Greenwich Mean Time (GMT), without exception.



[.* MUST .*]	
This is indicated in the first two formats by the inclusion of "GMT" as the three-letter abbreviation for time zone, and MUST be assumed when reading the asctime format.



[.* MUST .*]	
HTTP-date is case sensitive and MUST NOT include additional LWS beyond that specifically included as SP in the grammar.



[.* MUST .*]	
However, the definition associated with a MIME character set name MUST fully specify the mapping to be performed from octets to characters.



[.* MUST .*]	
 Although HTTP allows an arbitrary token to be used as a charset value, any token that has a predefined value within the IANA Character Set registry [19] MUST represent the character set defined by that registry.



[.* SHOULD .*]	
Applications SHOULD limit their use of character sets to those defined by the IANA registry.



[.* SHOULD .*]	[.* MAY .*]	
Senders wishing to defeat this behavior MAY include a charset parameter even when the charset is ISO-8859-1 and SHOULD do so when it is known that it will not confuse the recipient.



[.* MUST .*]	
HTTP/1.1 recipients MUST respect the charset label provided by the sender; and those user agents that have a provision to "guess" a charset MUST use the charset from the content-type field if they support that charset, rather than the recipient's preference, when initially displaying a document.



[.* SHOULD .*]	
For compatibility with previous implementations of HTTP, applications SHOULD consider "x-gzip" and "x-compress" to be equivalent to "gzip" and "compress" respectively.



[.* SHOULD .*]	
This content-coding is used only in the Accept- Encoding header, and SHOULD NOT be used in the Content-Encoding header.



[.* SHOULD .*]	
 New content-coding value tokens SHOULD be registered; to allow interoperability between clients and servers, specifications of the content coding algorithms needed to implement a new value SHOULD be publicly available and adequate for independent implementation, and conform to the purpose of content coding defined in this section.



[.* MUST .*]	
 Whenever a transfer-coding is applied to a message-body, the set of transfer-codings MUST include "chunked", unless the message is terminated by closing the connection.



[.* MUST .*]	
When the "chunked" transfer- coding is used, it MUST be the last transfer-coding applied to the message-body.



[.* MUST .*]	
The "chunked" transfer-coding MUST NOT be applied more than once to a message-body.



[.* SHOULD .*]	
 New transfer-coding value tokens SHOULD be registered in the same way as new content-coding value tokens (section 3.5).



[.* SHOULD .*]	
 A server which receives an entity-body with a transfer-coding it does not understand SHOULD return 501 (Unimplemented), and close the connection.



[.* MUST .*]	
A server MUST NOT send transfer-codings to an HTTP/1.0 client.



[.* MUST .*]	
A server using chunked transfer-coding in a response MUST NOT use the trailer for any header fields unless at least one of the following is true:



[.* MUST .*]	
 All HTTP/1.1 applications MUST be able to receive and decode the "chunked" transfer-coding, and MUST ignore chunk-extension extensions they do not understand.



[.* MAY .*]	
 Parameters MAY follow the type/subtype in the form of attribute/value pairs (as defined in section 3.6).



[.* MUST .*]	
Linear white space (LWS) MUST NOT be used between the type and subtype, nor between an attribute and its value.



[.* SHOULD .*]	
When sending data to older HTTP applications, implementations SHOULD only use media type parameters when they are required by that type/subtype definition.



[.* MUST .*]	
An entity-body transferred via HTTP messages MUST be represented in the appropriate canonical form prior to its transmission except for "text" types, as defined in the next paragraph.



[.* MUST .*]	
HTTP applications MUST accept CRLF, bare CR, and bare LF as being representative of a line break in text media received via HTTP.



[.* MUST .*]	
This flexibility regarding line breaks applies only to text media in the entity-body; a bare CR or LF MUST NOT be substituted for CRLF within any of the HTTP control structures (such as header fields and multipart boundaries).



[.* MUST .*]	
 If an entity-body is encoded with a content-coding, the underlying data MUST be in a form defined above prior to being encoded.



[.* MUST .*]	
Data in character sets other than "ISO-8859-1" or its subsets MUST be labeled with an appropriate charset value.



[.* MUST .*]	
All multipart types share a common syntax, as defined in section 5.1.1 of RFC 2046 [40], and MUST include a boundary parameter as part of the media type value.



[.* MUST .*]	
The message body is itself a protocol element and MUST therefore use only CRLF to represent line breaks between body-parts.



[.* MUST .*]	
Unlike in RFC 2046, the epilogue of any multipart message MUST be empty; HTTP applications MUST NOT transmit the epilogue (even if the original multipart contains an epilogue).



[.* SHOULD .*]	
In all other cases, an HTTP user agent SHOULD follow the same or similar behavior as a MIME user agent would upon receipt of a multipart type.



[.* SHOULD .*]	
 In general, an HTTP user agent SHOULD follow the same or similar behavior as a MIME user agent would upon receipt of a multipart type.



[.* MUST .*]	
If an application receives an unrecognized multipart subtype, the application MUST treat it as being equivalent to "multipart/mixed".



[.* SHOULD .*]	
 User-Agent: CERN-LineMode/2.15 libwww/2.17b3 Server: Apache/0.8.4 Product tokens SHOULD be short and to the point.



[.* MUST .*]	
They MUST NOT be used for advertising or other non-essential information.



[.* SHOULD .*]	[.* MAY .*]	
Although any token character MAY appear in a product-version, this token SHOULD only be used for a version identifier (i.e., successive versions of the same product SHOULD only differ in the product-version portion of the product value).



[.* MUST .*]	
HTTP/1.1 applications MUST NOT generate more than three digits after the decimal point.



[.* SHOULD .*]	
User configuration of these values SHOULD also be limited in this fashion.



[.* MAY .*]	
 A "strong entity tag" MAY be shared by two entities of a resource only if they are equivalent by octet equality.



[.* MAY .*]	
 A "weak entity tag," indicated by the "W/" prefix, MAY be shared by two entities of a resource only if the entities are equivalent and could be substituted for each other with no significant change in semantics.



[.* MUST .*]	
 An entity tag MUST be unique across all versions of all entities associated with a particular resource.



[.* MAY .*]	
A given entity tag value MAY be used for entities obtained by requests on different URIs.



[.* MAY .*]	
HTTP/1.1 implementations MAY ignore ranges specified using other units.



[.* SHOULD .*]	
 In the interest of robustness, servers SHOULD ignore any empty line(s) received where a Request-Line is expected.



[.* MUST .*]	
To restate what is explicitly forbidden by the BNF, an HTTP/1.1 client MUST NOT preface or follow a request with an extra CRLF.



[.* MAY .*]	
The field value MAY be preceded by any amount of LWS, though a single SP is preferred.



[.* MAY .*]	
Such leading or trailing LWS MAY be removed without changing the semantics of the field value.



[.* MAY .*]	
Any LWS that occurs between field-content MAY be replaced with a single SP before interpreting the field value or forwarding the message downstream.



[.* MAY .*]	
 Multiple message-header fields with the same field-name MAY be present in a message if and only if the entire field-value for that header field is defined as a comma-separated list [i.e., #(values)].



[.* MUST .*]	
It MUST be possible to combine the multiple header fields into one "field-name: field-value" pair, without changing the semantics of the message, by appending each subsequent field-value to the first, each separated by a comma.



[.* MUST .*]	
The order in which header fields with the same field-name are received is therefore significant to the interpretation of the combined field value, and thus a proxy MUST NOT change the order of these field values when a message is forwarded.



[.* MUST .*]	
 Transfer-Encoding MUST be used to indicate any transfer-codings applied by an application to ensure safe and proper transfer of the message.



[.* MAY .*]	
Transfer-Encoding is a property of the message, not of the entity, and thus MAY be added or removed by any application along the request/response chain.



[.* MUST .*]	
A message-body MUST NOT be included in a request if the specification of the request method (section 5.1.1) does not allow sending an entity-body in requests.



[.* SHOULD .*]	
A server SHOULD read and forward a message-body on any request; if the request method does not include defined semantics for an entity-body, then the message-body SHOULD be ignored when handling the request.



[.* MUST .*]	
All responses to the HEAD request method MUST NOT include a message-body, even though the presence of entity- header fields might lead one to believe they do.



[.* MUST .*]	
All 1xx (informational), 204 (no content), and 304 (not modified) responses MUST NOT include a message-body.



[.* MAY .*]	
All other responses do include a message-body, although it MAY be of zero length.



[.* MUST .*]	
The Content-Length header field MUST NOT be sent if these two lengths are different (i.e., if a Transfer-Encoding header field is present).



[.* MUST .*]	
If a message is received with both a Transfer-Encoding header field and a Content-Length header field, the latter MUST be ignored.



[.* MUST .*]	
 A range header might be forwarded by a 1.0 proxy that does not understand multipart/byteranges; in this case the server MUST delimit the message using methods defined in items 1,3 or 5 of this section.



[.* MUST .*]	
 For compatibility with HTTP/1.0 applications, HTTP/1.1 requests containing a message-body MUST include a valid Content-Length header field unless the server is known to be HTTP/1.1 compliant.



[.* SHOULD .*]	
If a request contains a message-body and a Content-Length is not given, the server SHOULD respond with 400 (bad request) if it cannot determine the length of the message, or with 411 (length required) if it wishes to insist on receiving a valid Content-Length.



[.* MUST .*]	
 All HTTP/1.1 applications that receive entities MUST accept the "chunked" transfer-coding (section 3.6), thus allowing this mechanism to be used for messages when the message length cannot be determined in advance.



[.* MUST .*]	
 Messages MUST NOT include both a Content-Length header field and a non-identity transfer-coding.



[.* MUST .*]	
If the message does include a non- identity transfer-coding, the Content-Length MUST be ignored.



[.* MUST .*]	
 When a Content-Length is given in a message where a message-body is allowed, its field value MUST exactly match the number of OCTETs in the message-body.



[.* MUST .*]	
HTTP/1.1 user agents MUST notify the user when an invalid length is received and detected.



[.* SHOULD .*]	
An origin server SHOULD return the status code 405 (Method Not Allowed) if the method is known by the origin server but not allowed for the requested resource, and 501 (Not Implemented) if the method is unrecognized or not implemented by the origin server.



[.* MUST .*]	
The methods GET and HEAD MUST be supported by all general-purpose servers.



[.* MUST .*]	
All other methods are OPTIONAL; however, if the above methods are implemented, they MUST be implemented with the same semantics as those specified in section 9.



[.* MAY .*]	
Note that the proxy MAY forward the request on to another proxy or directly to the server specified by the absoluteURI.



[.* MUST .*]	
In order to avoid request loops, a proxy MUST be able to recognize all of its server names, including any aliases, local variations, and the numeric IP address.



[.* MUST .*]	
 To allow for transition to absoluteURIs in all requests in future versions of HTTP, all HTTP/1.1 servers MUST accept the absoluteURI form in requests, even though HTTP/1.1 clients will only generate them in requests to proxies.



[.* MUST .*]	
In this case the absolute path of the URI MUST be transmitted (see section 3.2.1, abs_path) as the Request-URI, and the network location of the URI (authority) MUST be transmitted in a Host header field.



[.* MUST .*]	
Note that the absolute path cannot be empty; if none is present in the original URI, it MUST be given as "/" (the server root).



[.* MUST .*]	
If the Request-URI is encoded using the "% HEX HEX" encoding [42], the origin server MUST decode the Request-URI in order to properly interpret the request.



[.* SHOULD .*]	
Servers SHOULD respond to invalid Request-URIs with an appropriate status code.



[.* MUST .*]	
 A transparent proxy MUST NOT rewrite the "abs_path" part of the received Request-URI when forwarding it to the next inbound server, except as noted above to replace a null abs_path with "/".



[.* MAY .*]	
 An origin server that does not allow resources to differ by the requested host MAY ignore the Host header field value when determining the resource identified by an HTTP/1.1 request.



[.* MUST .*]	
 An origin server that does differentiate resources based on the host requested (sometimes referred to as virtual hosts or vanity host names) MUST use the following rules for determining the requested resource on an HTTP/1.1 request:



[.* MUST .*]	
Any Host header field value in the request MUST be ignored.



[.* MUST .*]	
If the host as determined by rule 1 or 2 is not a valid host on the server, the response MUST be a 400 (Bad Request) error message.



[.* MAY .*]	
 Recipients of an HTTP/1.0 request that lacks a Host header field MAY attempt to use heuristics (e.g,, examination of the URI path for something unique to a particular host) in order to determine what exact resource is being requested.



[.* MAY .*]	
However, new or experimental header fields MAY be given the semantics of request- header fields if all parties in the communication recognize them to be request-header fields.



[.* MAY .*]	
The reason phrases listed here are only recommendations -- they MAY be replaced by local equivalents without affecting the protocol.



[.* MUST .*]	
However, applications MUST understand the class of any status code, as indicated by the first digit, and treat any unrecognized response as being equivalent to the x00 status code of that class, with the exception that an unrecognized response MUST NOT be cached.



[.* SHOULD .*]	
In such cases, user agents SHOULD present to the user the entity returned with the response, since that entity is likely to include human- readable information which will explain the unusual status.



[.* MAY .*]	
However, new or experimental header fields MAY be given the semantics of response- header fields if all parties in the communication recognize them to be response-header fields.



[.* MAY .*]	
 Request and Response messages MAY transfer an entity if not otherwise restricted by the request method or response status code.



[.* SHOULD .*]	[.* MUST .*]	
Unrecognized header fields SHOULD be ignored by the recipient and MUST be forwarded by transparent proxies.



[.* SHOULD .*]	
 Any HTTP/1.1 message containing an entity-body SHOULD include a Content-Type header field defining the media type of that body.



[.* MAY .*]	
If and only if the media type is not given by a Content-Type field, the recipient MAY attempt to guess the media type via inspection of its content and/or the name extension(s) of the URI used to identify the resource.



[.* SHOULD .*]	
If the media type remains unknown, the recipient SHOULD treat it as type "application/octet-stream".



[.* SHOULD .*]	
 HTTP implementations SHOULD implement persistent connections.



[.* SHOULD .*]	
That is, unless otherwise indicated, the client SHOULD assume that the server will maintain a persistent connection, even after error responses from the server.



[.* MUST .*]	
Once a close has been signaled, the client MUST NOT send any more requests on that connection.



[.* MAY .*]	
 An HTTP/1.1 server MAY assume that a HTTP/1.1 client intends to maintain a persistent connection unless a Connection header including the connection-token "close" was sent in the request.



[.* SHOULD .*]	
If the server chooses to close the connection immediately after sending the response, it SHOULD send a Connection header including the connection-token close.



[.* MAY .*]	
 An HTTP/1.1 client MAY expect a connection to remain open, but would decide to keep it open based on whether the response from a server contains a Connection header with the connection-token close.



[.* SHOULD .*]	
In case the client does not want to maintain a connection for more than that request, it SHOULD send a Connection header including the connection-token close.



[.* SHOULD .*]	
 Clients and servers SHOULD NOT assume that a persistent connection is maintained for HTTP versions less than 1.1 unless it is explicitly signaled.



[.* MUST .*]	
 In order to remain persistent, all messages on the connection MUST have a self-defined message length (i.e., one not defined by closure of the connection), as described in section 4.4.



[.* MAY .*]	
 A client that supports persistent connections MAY "pipeline" its requests (i.e., send multiple requests without waiting for each response).



[.* MUST .*]	
A server MUST send its responses to those requests in the same order that the requests were received.



[.* SHOULD .*]	
 Clients which assume persistent connections and pipeline immediately after connection establishment SHOULD be prepared to retry their connection if the first pipelined attempt fails.



[.* MUST .*]	
If a client does such a retry, it MUST NOT pipeline before it knows the connection is persistent.



[.* MUST .*]	
Clients MUST also be prepared to resend their requests if the server closes the connection before sending all of the corresponding responses.



[.* SHOULD .*]	
 Clients SHOULD NOT pipeline requests using non-idempotent methods or non-idempotent sequences of methods (see section 9.1.2).



[.* SHOULD .*]	
A client wishing to send a non-idempotent request SHOULD wait to send that request until it has received the response status for the previous request.



[.* MUST .*]	
 The proxy server MUST signal persistent connections separately with its clients and the origin servers (or other proxy servers) that it connects to.



[.* MUST .*]	
 A proxy server MUST NOT establish a HTTP/1.1 persistent connection with an HTTP/1.0 client (but see RFC 2068 [33] for information and discussion of the problems with the Keep-Alive header implemented by many HTTP/1.0 clients).



[.* SHOULD .*]	
When a client or server wishes to time-out it SHOULD issue a graceful close on the transport connection.



[.* SHOULD .*]	
Clients and servers SHOULD both constantly watch for the other side of the transport close, and respond to it as appropriate.



[.* MAY .*]	
 A client, server, or proxy MAY close the transport connection at any time.



[.* MUST .*]	
 This means that clients, servers, and proxies MUST be able to recover from asynchronous close events.



[.* SHOULD .*]	
Client software SHOULD reopen the transport connection and retransmit the aborted sequence of requests without user interaction so long as the request sequence is idempotent (see section 9.1.2).



[.* MUST .*]	[.* MAY .*]	
Non-idempotent methods or sequences MUST NOT be automatically retried, although user agents MAY offer a human operator the choice of retrying the request(s).



[.* MAY .*]	
Confirmation by user-agent software with semantic understanding of the application MAY substitute for user confirmation.



[.* SHOULD .*]	
The automatic retry SHOULD NOT be repeated if the second sequence of requests fails.



[.* SHOULD .*]	
 Servers SHOULD always respond to at least one request per connection, if at all possible.



[.* SHOULD .*]	
Servers SHOULD NOT close a connection in the middle of transmitting a response, unless a network or client failure is suspected.



[.* SHOULD .*]	
 Clients that use persistent connections SHOULD limit the number of simultaneous connections that they maintain to a given server.



[.* SHOULD .*]	
A single-user client SHOULD NOT maintain more than 2 connections with any server or proxy.



[.* SHOULD .*]	
A proxy SHOULD use up to 2*N connections to another server or proxy, where N is the number of simultaneously active users.



[.* SHOULD .*]	
 HTTP/1.1 servers SHOULD maintain persistent connections and use TCP's flow control mechanisms to resolve temporary overloads, rather than terminating connections with the expectation that clients will retry.



[.* SHOULD .*]	
 An HTTP/1.1 (or later) client sending a message-body SHOULD monitor the network connection for an error status while it is transmitting the request.



[.* SHOULD .*]	
If the client sees an error status, it SHOULD immediately cease transmitting the body.



[.* MAY .*]	
If the body is being sent using a "chunked" encoding (section 3.6), a zero length chunk and empty trailer MAY be used to prematurely mark the end of the message.



[.* MUST .*]	
If the body was preceded by a Content-Length header, the client MUST close the connection.



[.* MUST .*]	
 - If a client will wait for a 100 (Continue) response before sending the request body, it MUST send an Expect request-header field (section 14.20) with the "100-continue" expectation.



[.* MUST .*]	
 - A client MUST NOT send an Expect request-header field (section 14.20) with the "100-continue" expectation if it does not intend to send a request body.



[.* SHOULD .*]	
Therefore, when a client sends this header field to an origin server (possibly via a proxy) from which it has never seen a 100 (Continue) status, the client SHOULD NOT wait for an indefinite period before sending the request body.



[.* MUST .*]	
 - Upon receiving a request which includes an Expect request-header field with the "100-continue" expectation, an origin server MUST either respond with 100 (Continue) status and continue to read from the input stream, or respond with a final status code.



[.* MUST .*]	
The origin server MUST NOT wait for the request body before sending the 100 (Continue) response.



[.* MAY .*]	
If it responds with a final status code, it MAY close the transport connection or it MAY continue to read and discard the rest of the request.



[.* MUST .*]	
It MUST NOT perform the requested method if it returns a final status code.



[.* SHOULD .*]	[.* MUST .*]	
 - An origin server SHOULD NOT send a 100 (Continue) response if the request message does not include an Expect request-header field with the "100-continue" expectation, and MUST NOT send a 100 (Continue) response if such a request comes from an HTTP/1.0 (or earlier) client.



[.* MAY .*]	
There is an exception to this rule: for compatibility with RFC 2068, a server MAY send a 100 (Continue) status in response to an HTTP/1.1 PUT or POST request that does not include an Expect request-header field with the "100- continue" expectation.



[.* MAY .*]	
 - An origin server MAY omit a 100 (Continue) response if it has already received some or all of the request body for the corresponding request.



[.* MUST .*]	
 - An origin server that sends a 100 (Continue) response MUST ultimately send a final status code, once the request body is received and processed, unless it terminates the transport connection prematurely.



[.* SHOULD .*]	
 - If an origin server receives a request that does not include an Expect request-header field with the "100-continue" expectation, the request includes a request body, and the server responds with a final status code before reading the entire request body from the transport connection, then the server SHOULD NOT close the transport connection until it has read the entire request, or until the client closes the connection.



[.* MUST .*]	
 - If a proxy receives a request that includes an Expect request- header field with the "100-continue" expectation, and the proxy either knows that the next-hop server complies with HTTP/1.1 or higher, or does not know the HTTP version of the next-hop server, it MUST forward the request, including the Expect header field.



[.* MUST .*]	
- If the proxy knows that the version of the next-hop server is HTTP/1.0 or lower, it MUST NOT forward the request, and it MUST respond with a 417 (Expectation Failed) status.



[.* SHOULD .*]	
 - Proxies SHOULD maintain a cache recording the HTTP version numbers received from recently-referenced next-hop servers.



[.* MUST .*]	
 - A proxy MUST NOT forward a 100 (Continue) response if the request message was received from an HTTP/1.0 (or earlier) client and did not include an Expect request-header field with the "100-continue" expectation.



[.* SHOULD .*]	
 If an HTTP/1.1 client sends a request which includes a request body, but which does not include an Expect request-header field with the "100-continue" expectation, and if the client is not directly connected to an HTTP/1.1 origin server, and if the client sees the connection close before receiving any status from the server, the client SHOULD retry the request.



[.* MAY .*]	
If the client does retry this request, it MAY use the following "binary exponential backoff" algorithm to be assured of obtaining a reliable response:



[.* SHOULD .*]	
 - SHOULD NOT continue and



[.* SHOULD .*]	
 - SHOULD close the connection if it has not completed sending the request message.



[.* MUST .*]	
 The Host request-header field (section 14.23) MUST accompany all HTTP/1.1 requests.



[.* SHOULD .*]	
 In particular, the convention has been established that the GET and HEAD methods SHOULD NOT have the significance of taking an action other than retrieval.



[.* SHOULD .*]	
Also, the methods OPTIONS and TRACE SHOULD NOT have side effects, and so are inherently idempotent.



[.* MUST .*]	
 If the OPTIONS request includes an entity-body (as indicated by the presence of Content-Length or Transfer-Encoding), then the media type MUST be indicated by a Content-Type field.



[.* MAY .*]	
A server that does not support such an extension MAY discard the request body.



[.* SHOULD .*]	
 A 200 response SHOULD include any header fields that indicate optional features implemented by the server and applicable to that resource (e.g,, Allow), possibly including extensions not defined by this specification.



[.* SHOULD .*]	
The response body, if any, SHOULD also include information about the communication options.



[.* MAY .*]	
Content negotiation MAY be used to select the appropriate response format.



[.* MUST .*]	
If no response body is included, the response MUST include a Content-Length field with a field-value of "0".



[.* MAY .*]	
 The Max-Forwards request-header field MAY be used to target a specific proxy in the request chain.



[.* MUST .*]	
When a proxy receives an OPTIONS request on an absoluteURI for which request forwarding is permitted, the proxy MUST check for a Max-Forwards field.



[.* SHOULD .*]	[.* MUST .*]	
If the Max-Forwards field-value is zero ("0"), the proxy MUST NOT forward the message; instead, the proxy SHOULD respond with its own communication options.



[.* MUST .*]	
If the Max-Forwards field-value is an integer greater than zero, the proxy MUST decrement the field-value when it forwards the request.



[.* MUST .*]	
If no Max-Forwards field is present in the request, then the forwarded request MUST NOT include a Max-Forwards field.



[.* MUST .*]	
 The HEAD method is identical to GET except that the server MUST NOT return a message-body in the response.



[.* SHOULD .*]	
The metainformation contained in the HTTP headers in response to a HEAD request SHOULD be identical to the information sent in response to a GET request.



[.* MAY .*]	
 The response to a HEAD request MAY be cacheable in the sense that the information contained in the response MAY be used to update a previously cached entity from that resource.



[.* MUST .*]	
If the new field values indicate that the cached entity differs from the current entity (as would be indicated by a change in Content-Length, Content-MD5, ETag or Last-Modified), then the cache MUST treat the cache entry as stale.



[.* SHOULD .*]	
If a resource has been created on the origin server, the response SHOULD be 201 (Created) and contain an entity which describes the status of the request and refers to the new resource, and a Location header (see section 14.30).



[.* MUST .*]	
 POST requests MUST obey the message transmission requirements set out in section 8.2.



[.* SHOULD .*]	
If the Request-URI refers to an already existing resource, the enclosed entity SHOULD be considered as a modified version of the one residing on the origin server.



[.* MUST .*]	
If a new resource is created, the origin server MUST inform the user agent via the 201 (Created) response.



[.* SHOULD .*]	
If an existing resource is modified, either the 200 (OK) or 204 (No Content) response codes SHOULD be sent to indicate successful completion of the request.



[.* SHOULD .*]	
If the resource could not be created or modified with the Request-URI, an appropriate error response SHOULD be given that reflects the nature of the problem.



[.* MUST .*]	
The recipient of the entity MUST NOT ignore any Content-* (e.g, Content-Range) headers that it does not understand or implement and MUST return a 501 (Not Implemented) response in such cases.



[.* SHOULD .*]	
 If the request passes through a cache and the Request-URI identifies one or more currently cached entities, those entries SHOULD be treated as stale.



[.* MUST .*]	
In contrast, the URI in a PUT request identifies the entity enclosed with the request -- the user agent knows what URI is intended and the server MUST NOT attempt to apply the request to some other resource.



[.* MUST .*]	[.* MAY .*]	
If the server desires that the request be applied to a different URI, it MUST send a 301 (Moved Permanently) response; the user agent MAY then make its own decision regarding whether or not to redirect the request.



[.* MAY .*]	
 A single resource MAY be identified by many different URIs.



[.* MUST .*]	
 PUT requests MUST obey the message transmission requirements set out in section 8.2.



[.* SHOULD .*]	
 Unless otherwise specified for a particular entity-header, the entity-headers in the PUT request SHOULD be applied to the resource created or modified by the PUT.



[.* MAY .*]	
This method MAY be overridden by human intervention (or other means) on the origin server.



[.* SHOULD .*]	
However, the server SHOULD NOT indicate success unless, at the time the response is given, it intends to delete the resource or move it to an inaccessible location.



[.* SHOULD .*]	
 A successful response SHOULD be 200 (OK) if the response includes an entity describing the status, 202 (Accepted) if the action has not yet been enacted, or 204 (No Content) if the action has been enacted but the response does not include an entity.



[.* SHOULD .*]	
 If the request passes through a cache and the Request-URI identifies one or more currently cached entities, those entries SHOULD be treated as stale.



[.* SHOULD .*]	
The final recipient of the request SHOULD reflect the message received back to the client as the entity-body of a 200 (OK) response.



[.* MUST .*]	
A TRACE request MUST NOT include an entity.



[.* SHOULD .*]	
 If the request is valid, the response SHOULD contain the entire request message in the entity-body, with a Content-Type of "message/http".



[.* MUST .*]	
Responses to this method MUST NOT be cached.



[.* MUST .*]	
Since HTTP/1.0 did not define any 1xx status codes, servers MUST NOT send a 1xx response to an HTTP/1.0 client except under experimental conditions.



[.* MUST .*]	
 A client MUST be prepared to accept one or more 1xx status responses prior to a regular response, even if the client does not expect a 100 (Continue) status message.



[.* MAY .*]	
Unexpected 1xx status responses MAY be ignored by a user agent.



[.* MUST .*]	
 Proxies MUST forward 1xx responses, unless the connection between the proxy and its client has been closed, or unless the proxy itself requested the generation of the 1xx response.



[.* SHOULD .*]	
 The client SHOULD continue with its request.



[.* SHOULD .*]	
The client SHOULD continue by sending the remainder of the request or, if the request has already been completed, ignore this response.



[.* MUST .*]	
The server MUST send a final response after the request has been completed.



[.* SHOULD .*]	
 The protocol SHOULD be switched only when it is advantageous to do so.



[.* SHOULD .*]	
The response SHOULD include an entity containing a list of resource characteristics and location(s) from which the user or user agent can choose the one most appropriate.



[.* MUST .*]	
The origin server MUST create the resource before returning the 201 status code.



[.* SHOULD .*]	
If the action cannot be carried out immediately, the server SHOULD respond with 202 (Accepted) response instead.



[.* MAY .*]	
 A 201 response MAY contain an ETag response header field indicating the current value of the entity tag for the requested variant just created, see section 14.19.



[.* SHOULD .*]	
The entity returned with this response SHOULD include an indication of the request's current status and either a pointer to a status monitor or some estimate of when the user can expect the request to be fulfilled.



[.* MAY .*]	
The set presented MAY be a subset or superset of the original version.



[.* SHOULD .*]	[.* MAY .*]	
The response MAY include new or updated metainformation in the form of entity-headers, which if present SHOULD be associated with the requested variant.



[.* SHOULD .*]	
 If the client is a user agent, it SHOULD NOT change its document view from that which caused the request to be sent.



[.* SHOULD .*]	
This response is primarily intended to allow input for actions to take place without causing a change to the user agent's active document view, although any new or updated metainformation SHOULD be applied to the document currently in the user agent's active view.



[.* MUST .*]	
 The 204 response MUST NOT include a message-body, and thus is always terminated by the first empty line after the header fields.



[.* SHOULD .*]	
 The server has fulfilled the request and the user agent SHOULD reset the document view which caused the request to be sent.



[.* MUST .*]	
The response MUST NOT include an entity.



[.* MUST .*]	[.* MAY .*]	
The request MUST have included a Range header field (section 14.35) indicating the desired range, and MAY have included an If-Range header field (section 14.27) to make the request conditional.



[.* MUST .*]	
 The response MUST include the following header fields:



[.* MUST .*]	
If a Content-Length header field is present in the response, its value MUST match the actual number of OCTETs transmitted in the message-body.



[.* SHOULD .*]	
 If the 206 response is the result of an If-Range request that used a strong cache validator (see section 13.3.3), the response SHOULD NOT include other entity-headers.



[.* MUST .*]	
If the response is the result of an If-Range request that used a weak validator, the response MUST NOT include other entity-headers; this prevents inconsistencies between cached entity-bodies and updated headers.



[.* MUST .*]	
Otherwise, the response MUST include all of the entity-headers that would have been returned with a 200 (OK) response to the same request.



[.* MUST .*]	
 A cache MUST NOT combine a 206 response with other previously cached content if the ETag or Last-Modified headers do not match exactly, see 13.5.4.



[.* MUST .*]	
 A cache that does not support the Range and Content-Range headers MUST NOT cache 206 (Partial) responses.



[.* MAY .*]	
The action required MAY be carried out by the user agent without interaction with the user if and only if the method used in the second request is GET or HEAD.



[.* SHOULD .*]	
A client SHOULD detect infinite redirection loops, since such loops generate network traffic for each redirection.



[.* SHOULD .*]	
 Unless it was a HEAD request, the response SHOULD include an entity containing a list of resource characteristics and location(s) from which the user or user agent can choose the one most appropriate.



[.* MAY .*]	
Depending upon the format and the capabilities of the user agent, selection of the most appropriate choice MAY be performed automatically.



[.* SHOULD .*]	[.* MAY .*]	
 If the server has a preferred choice of representation, it SHOULD include the specific URI for that representation in the Location field; user agents MAY use the Location field value for automatic redirection.



[.* SHOULD .*]	
 The requested resource has been assigned a new permanent URI and any future references to this resource SHOULD use one of the returned URIs.



[.* SHOULD .*]	
 The new permanent URI SHOULD be given by the Location field in the response.



[.* SHOULD .*]	
Unless the request method was HEAD, the entity of the response SHOULD contain a short hypertext note with a hyperlink to the new URI(s).



[.* MUST .*]	
 If the 301 status code is received in response to a request other than GET or HEAD, the user agent MUST NOT automatically redirect the request unless it can be confirmed by the user, since this might change the conditions under which the request was issued.



[.* SHOULD .*]	
Since the redirection might be altered on occasion, the client SHOULD continue to use the Request-URI for future requests.



[.* SHOULD .*]	
 The temporary URI SHOULD be given by the Location field in the response.



[.* SHOULD .*]	
Unless the request method was HEAD, the entity of the response SHOULD contain a short hypertext note with a hyperlink to the new URI(s).



[.* MUST .*]	
If the 302 status code is received in response to a request other than GET or HEAD, the user agent MUST NOT automatically redirect the request unless it can be confirmed by the user, since this might change the conditions under which the request was issued.



[.* SHOULD .*]	
 The response to the request can be found under a different URI and SHOULD be retrieved using a GET method on that resource.



[.* MUST .*]	
The 303 response MUST NOT be cached, but the response to the second (redirected) request might be cacheable.



[.* SHOULD .*]	
 The different URI SHOULD be given by the Location field in the response.



[.* SHOULD .*]	
Unless the request method was HEAD, the entity of the response SHOULD contain a short hypertext note with a hyperlink to the new URI(s).



[.* SHOULD .*]	
 If the client has performed a conditional GET request and access is allowed, but the document has not been modified, the server SHOULD respond with this status code.



[.* MUST .*]	
The 304 response MUST NOT contain a message-body, and thus is always terminated by the first empty line after the header fields.



[.* MUST .*]	
 The response MUST include the following header fields:



[.* SHOULD .*]	
 If the conditional GET used a strong cache validator (see section 13.3.3), the response SHOULD NOT include other entity-headers.



[.* MUST .*]	
Otherwise (i.e., the conditional GET used a weak validator), the response MUST NOT include other entity-headers; this prevents inconsistencies between cached entity-bodies and updated headers.



[.* MUST .*]	
 If a 304 response indicates an entity not currently cached, then the cache MUST disregard the response and repeat the request without the conditional.



[.* MUST .*]	
 If a cache uses a received 304 response to update a cache entry, the cache MUST update the entry to reflect any new field values given in the response.



[.* MUST .*]	
 The requested resource MUST be accessed through the proxy given by the Location field.



[.* MUST .*]	
305 responses MUST only be generated by origin servers.



[.* SHOULD .*]	[.* MAY .*]	
Since the redirection MAY be altered on occasion, the client SHOULD continue to use the Request-URI for future requests.



[.* SHOULD .*]	
 The temporary URI SHOULD be given by the Location field in the response.



[.* SHOULD .*]	
Unless the request method was HEAD, the entity of the response SHOULD contain a short hypertext note with a hyperlink to the new URI(s) , since many pre-HTTP/1.1 user agents do not understand the 307 status.



[.* SHOULD .*]	
Therefore, the note SHOULD contain the information necessary for a user to repeat the original request on the new URI.



[.* MUST .*]	
 If the 307 status code is received in response to a request other than GET or HEAD, the user agent MUST NOT automatically redirect the request unless it can be confirmed by the user, since this might change the conditions under which the request was issued.



[.* SHOULD .*]	
Except when responding to a HEAD request, the server SHOULD include an entity containing an explanation of the error situation, and whether it is a temporary or permanent condition.



[.* SHOULD .*]	
User agents SHOULD display any included entity to the user.



[.* SHOULD .*]	
 If the client is sending data, a server implementation using TCP SHOULD be careful to ensure that the client acknowledges receipt of the packet(s) containing the response, before the server closes the input connection.



[.* SHOULD .*]	
The client SHOULD NOT repeat the request without modifications.



[.* MUST .*]	
The response MUST include a WWW-Authenticate header field (section 14.47) containing a challenge applicable to the requested resource.



[.* MAY .*]	
The client MAY repeat the request with a suitable Authorization header field (section 14.8).



[.* SHOULD .*]	
If the 401 response contains the same challenge as the prior response, and the user agent has already attempted authentication at least once, then the user SHOULD be presented the entity that was given in the response, since that entity might include relevant diagnostic information.



[.* SHOULD .*]	
Authorization will not help and the request SHOULD NOT be repeated.



[.* SHOULD .*]	
If the request method was not HEAD and the server wishes to make public why the request has not been fulfilled, it SHOULD describe the reason for the refusal in the entity.



[.* SHOULD .*]	
The 410 (Gone) status code SHOULD be used if the server knows, through some internally configurable mechanism, that an old resource is permanently unavailable and has no forwarding address.



[.* MUST .*]	
The response MUST include an Allow header containing a list of valid methods for the requested resource.



[.* SHOULD .*]	
 Unless it was a HEAD request, the response SHOULD include an entity containing a list of available entity characteristics and location(s) from which the user or user agent can choose the one most appropriate.



[.* MAY .*]	
Depending upon the format and the capabilities of the user agent, selection of the most appropriate choice MAY be performed automatically.



[.* SHOULD .*]	
 If the response could be unacceptable, a user agent SHOULD temporarily stop receipt of more data and query the user for a decision on further actions.



[.* MUST .*]	
The proxy MUST return a Proxy-Authenticate header field (section 14.33) containing a challenge applicable to the proxy for the requested resource.



[.* MAY .*]	
The client MAY repeat the request with a suitable Proxy-Authorization header field (section 14.34).



[.* MAY .*]	
The client MAY repeat the request without modifications at any later time.



[.* SHOULD .*]	
The response body SHOULD include enough information for the user to recognize the source of the conflict.



[.* SHOULD .*]	
Clients with link editing capabilities SHOULD delete references to the Request-URI after user approval.



[.* SHOULD .*]	
If the server does not know, or has no facility to determine, whether or not the condition is permanent, the status code 404 (Not Found) SHOULD be used instead.



[.* MAY .*]	
The client MAY repeat the request if it adds a valid Content-Length header field containing the length of the message-body in the request message.



[.* MAY .*]	
The server MAY close the connection to prevent the client from continuing the request.



[.* SHOULD .*]	[.* MAY .*]	
 If the condition is temporary, the server SHOULD include a Retry- After header field to indicate that it is temporary and after what time the client MAY try again.



[.* SHOULD .*]	
 A server SHOULD return a response with this status code if a request included a Range request-header field (section 14.35), and none of the range-specifier values in this field overlap the current extent of the selected resource, and the request did not include an If-Range request-header field.



[.* SHOULD .*]	
 When this status code is returned for a byte-range request, the response SHOULD include a Content-Range entity-header field specifying the current length of the selected resource (see section 14.16).



[.* MUST .*]	
This response MUST NOT use the multipart/byteranges content- type.



[.* SHOULD .*]	
Except when responding to a HEAD request, the server SHOULD include an entity containing an explanation of the error situation, and whether it is a temporary or permanent condition.



[.* SHOULD .*]	
User agents SHOULD display any included entity to the user.



[.* MAY .*]	
If known, the length of the delay MAY be indicated in a Retry-After header.



[.* SHOULD .*]	
If no Retry-After is given, the client SHOULD handle the response as it would for a 500 response.



[.* SHOULD .*]	
The response SHOULD contain an entity describing why that version is not supported and what other protocols are supported by that server.



[.* MAY .*]	
Any response containing an entity-body MAY be subject to negotiation, including error responses.



[.* MAY .*]	
In order to improve the server's guess, the user agent MAY include request header fields (Accept, Accept-Language, Accept-Encoding, etc.)



[.* MAY .*]	
However, an origin server is not limited to these dimensions and MAY vary the response based on any aspect of the request, including information outside the request-header fields or within extension header fields not defined by this specification.



[.* MUST .*]	
 A correct cache MUST respond to a request with the most up-to-date response held by the cache that is appropriate to the request (see sections 13.2.5, 13.2.6, and 13.12) which meets one of the following conditions:



[.* MAY .*]	
 If a stored response is not "fresh enough" by the most restrictive freshness requirement of both the client and the origin server, in carefully considered circumstances the cache MAY still return the response with the appropriate Warning header (see section 13.1.5 and 14.46), unless such a response is prohibited (e.g,, by a "no-store" cache-directive, or by a "no-cache" cache-request-directive; see section 14.9).



[.* SHOULD .*]	[.* MUST .*]	
 If the cache can not communicate with the origin server, then a correct cache SHOULD respond as above if the response can be correctly served from the cache; if not it MUST return an error or warning indicating that there was a communication failure.



[.* SHOULD .*]	
 If a cache receives a response (either an entire response, or a 304 (Not Modified) response) that it would normally forward to the requesting client, and the received response is no longer fresh, the cache SHOULD forward it to the requesting client without adding a new Warning (but without removing any existing Warning headers).



[.* SHOULD .*]	
A cache SHOULD NOT attempt to revalidate a response simply because that response became stale in transit; this might lead to an infinite loop.



[.* MAY .*]	
A user agent that receives a stale response without a Warning MAY display a warning indication to the user.



[.* MUST .*]	
 Whenever a cache returns a response that is neither first-hand nor "fresh enough" (in the sense of condition 2 in section 13.1.1), it MUST attach a warning to that effect, using a Warning general-header.



[.* MAY .*]	
 Warnings MAY be used for other purposes, both cache-related and otherwise.



[.* MUST .*]	
The first digit indicates whether the Warning MUST or MUST NOT be deleted from a stored cache entry after a successful revalidation: 1xx  Warnings that describe the freshness or revalidation status of the response, and so MUST be deleted after a successful revalidation.



[.* MAY .*]	
1XX warn-codes MAY be generated by a cache only when validating a cached entry.



[.* MUST .*]	
It MUST NOT be generated by clients.



[.* MUST .*]	
 2xx  Warnings that describe some aspect of the entity body or entity headers that is not rectified by a revalidation (for example, a lossy compression of the entity bodies) and which MUST NOT be deleted after a successful revalidation.



[.* MAY .*]	
The text MAY be in any appropriate natural language (perhaps based on the client's Accept headers), and include an OPTIONAL indication of what character set is used.



[.* MAY .*]	
 Multiple warnings MAY be attached to a response (either by the origin server or by a cache), including multiple warnings with the same code number.



[.* SHOULD .*]	[.* MAY .*]	
The user agent SHOULD NOT default to either non-transparent behavior, or behavior that results in abnormally ineffective caching, but MAY be explicitly configured to do so by an explicit action of the user.



[.* SHOULD .*]	
 If the user has overridden the basic caching mechanisms, the user agent SHOULD explicitly indicate to the user whenever this results in the display of information that might not meet the server's transparency requirements (in particular, if the displayed entity is known to be stale).



[.* SHOULD .*]	
 If the user has overridden the caching mechanisms in a way that would abnormally reduce the effectiveness of caches, the user agent SHOULD continually indicate this state to the user (for example, by a display of a picture of currency in flames) so that the user does not inadvertently consume excess resources or suffer from excessive latency.



[.* MAY .*]	
 In some cases, the operator of a cache MAY choose to configure it to return stale responses even when not requested by clients.



[.* MUST .*]	
Whenever a cache returns a stale response, it MUST mark it as such (using a Warning header) enabling the client software to alert the user that there might be a potential problem.



[.* SHOULD .*]	
For this reason, a cache SHOULD NOT return a stale response if the client explicitly requests a first-hand or fresh one, unless it is impossible to comply for technical or policy reasons.



[.* MAY .*]	
 A client's request MAY specify the maximum age it is willing to accept of an unvalidated response; specifying a value of zero forces the cache(s) to revalidate all responses.



[.* MAY .*]	
A client MAY also specify the minimum time remaining before a response expires.



[.* MAY .*]	
 A client MAY also specify that it will accept stale responses, up to some maximum amount of staleness.



[.* MAY .*]	
The primary mechanism for avoiding requests is for an origin server to provide an explicit expiration time in the future, indicating that a response MAY be used to satisfy subsequent requests.



[.* MAY .*]	
 If an origin server wishes to force a semantically transparent cache to validate every request, it MAY assign an explicit expiration time in the past.



[.* SHOULD .*]	
This means that the response is always stale, and so the cache SHOULD validate it before using it for subsequent requests.



[.* SHOULD .*]	
 If an origin server wishes to force any HTTP/1.1 cache, no matter how it is configured, to validate every request, it SHOULD use the "must- revalidate" cache-control directive (see section 14.9).



[.* SHOULD .*]	
Hosts that use HTTP, but especially hosts running origin servers and caches, SHOULD use NTP [28] or some similar protocol to synchronize their clocks to a globally accurate time standard.



[.* MUST .*]	
Then, when an Age value is received, it MUST be interpreted relative to the time the request was initiated, not the time that the response was received.



[.* MUST .*]	
When a response is generated from a cache entry, the cache MUST include a single Age header field in the response with a value equal to the cache entry's current_age.



[.* MAY .*]	
 If none of Expires, Cache-Control: max-age, or Cache-Control: s- maxage (see section 14.9.3) appears in the response, and the response does not include other restrictions on caching, the cache MAY compute a freshness lifetime using a heuristic.



[.* MUST .*]	
The cache MUST attach Warning 113 to any response whose age is more than 24 hours if such warning has not already been added.



[.* SHOULD .*]	
 Also, if the response does have a Last-Modified time, the heuristic expiration value SHOULD be no more than some fraction of the interval since that time.



[.* MAY .*]	
 If a client performing a retrieval receives a non-first-hand response for a request that was already fresh in its own cache, and the Date header in its existing cache entry is newer than the Date on the new response, then the client MAY ignore the response.



[.* MAY .*]	
If so, it MAY retry the request with a "Cache-Control: max-age=0" directive (see section 14.9), to force a check with the origin server.



[.* MUST .*]	
 If a cache has two fresh responses for the same representation with different validators, it MUST use the one with the more recent Date header.



[.* SHOULD .*]	
 When a client tries to revalidate a cache entry, and the response it receives contains a Date header that appears to be older than the one for the existing entry, then the client SHOULD repeat the request unconditionally, and include



[.* MAY .*]	
If the Date values are equal, then the client MAY use either response (or MAY, if it is being extremely prudent, request a new response).



[.* MUST .*]	
Servers MUST NOT depend on clients being able to choose deterministically between responses generated during the same second, if their expiration times overlap.



[.* MAY .*]	
 Clients MAY issue simple (non-subrange) GET requests with either weak validators or strong validators.



[.* MUST .*]	
Clients MUST NOT use weak validators in other forms of request.



[.* MUST .*]	
 - The strong comparison function: in order to be considered equal, both validators MUST be identical in every way, and both MUST NOT be weak.



[.* MUST .*]	[.* MAY .*]	
 - The weak comparison function: in order to be considered equal, both validators MUST be identical in every way, but either or both of them MAY be tagged as "weak" without affecting the result.



[.* MAY .*]	
An implementation MAY use a value larger than 60 seconds, if it is believed that 60 seconds is too short.



[.* MAY .*]	
 If a client wishes to perform a sub-range retrieval on a value for which it has only a Last-Modified time and no opaque validator, it MAY do this only if the Last-Modified time is strong in the sense described here.



[.* MUST .*]	
 A cache or origin server receiving a conditional request, other than a full-body GET request, MUST use the strong comparison function to evaluate the condition.



[.* SHOULD .*]	
 - SHOULD send an entity tag validator unless it is not feasible to generate one.



[.* MAY .*]	
 - MAY send a weak entity tag instead of a strong entity tag, if performance considerations support the use of weak entity tags, or if it is unfeasible to send a strong entity tag.



[.* SHOULD .*]	
 - SHOULD send a Last-Modified value if it is feasible to send one, unless the risk of a breakdown in semantic transparency that could result from using this date in an If-Modified-Since header would lead to serious problems.



[.* MUST .*]	
 In order to be legal, a strong entity tag MUST change whenever the associated entity value changes in any way.



[.* SHOULD .*]	
A weak entity tag SHOULD change whenever the associated entity changes in a semantically significant way.



[.* MUST .*]	
 - If an entity tag has been provided by the origin server, MUST use that entity tag in any cache-conditional request (using If- Match or If-None-Match).



[.* SHOULD .*]	
 - If only a Last-Modified value has been provided by the origin server, SHOULD use that value in non-subrange cache-conditional requests (using If-Modified-Since).



[.* MAY .*]	
- If only a Last-Modified value has been provided by an HTTP/1.0 origin server, MAY use that value in subrange cache-conditional requests (using If-Unmodified-Since:).



[.* SHOULD .*]	
The user agent SHOULD provide a way to disable this, in case of difficulty.



[.* SHOULD .*]	
 - If both an entity tag and a Last-Modified value have been provided by the origin server, SHOULD use both validators in cache-conditional requests.



[.* MUST .*]	
 An HTTP/1.1 origin server, upon receiving a conditional request that includes both a Last-Modified date (e.g,, in an If-Modified-Since or If-Unmodified-Since header field) and one or more entity tags (e.g,, in an If-Match, If-None-Match, or If-Range header field) as cache validators, MUST NOT return a response status of 304 (Not Modified) unless doing so is consistent with all of the conditional header fields in the request.



[.* MUST .*]	
 An HTTP/1.1 caching proxy, upon receiving a conditional request that includes both a Last-Modified date and one or more entity tags as cache validators, MUST NOT return a locally cached response to the client unless that cached response is consistent with all of the conditional header fields in the request.



[.* MAY .*]	
 Unless specifically constrained by a cache-control (section 14.9) directive, a caching system MAY always store a successful response (see section 13.8) as a cache entry, MAY return it without validation if it is fresh, and MAY return it after successful validation.



[.* MAY .*]	
If there is neither a cache validator nor an explicit expiration time associated with a response, we do not expect it to be cached, but certain caches MAY violate this expectation (for example, when little or no network connectivity is available).



[.* MAY .*]	
 A response received with a status code of 200, 203, 206, 300, 301 or 410 MAY be stored by a cache and used in reply to a subsequent request, subject to the expiration mechanism, unless a cache-control directive prohibits caching.



[.* MUST .*]	
However, a cache that does not support the Range and Content-Range headers MUST NOT cache 206 (Partial Content) responses.



[.* MUST .*]	
 A response received with any other status code (e.g, status codes 302 and 307) MUST NOT be returned in a reply to a subsequent request unless there are cache-control directives or another header(s) that explicitly allow it.



[.* MUST .*]	
End-to-end headers in responses MUST be stored as part of a cache entry and MUST be transmitted in any response formed from a cache entry.



[.* MUST .*]	
 Other hop-by-hop headers MUST be listed in a Connection header, (section 14.10) to be introduced into HTTP/1.1 (or later).



[.* SHOULD .*]	
A transparent proxy SHOULD NOT modify an end-to-end header unless the definition of that header requires or specifically allows that.



[.* MUST .*]	
A transparent proxy MUST NOT modify any of the following fields in a request or response, and it MUST NOT add any of these fields if not already present:



[.* MUST .*]	
 A transparent proxy MUST NOT modify any of the following fields in a response:



[.* MAY .*]	
 but it MAY add any of these fields if not already present.



[.* MUST .*]	
If an Expires header is added, it MUST be given a field-value identical to that of the Date header in that response.



[.* MUST .*]	
 A  proxy MUST NOT modify or add any of the following fields in a message that contains the no-transform cache-control directive, or in any request:



[.* MUST .*]	[.* MAY .*]	
 A non-transparent proxy MAY modify or add these fields to a message that does not include no-transform, but if it does so, it MUST add a Warning 214 (Transformation applied) if one does not already appear in the message (see section 14.46).



[.* MAY .*]	
Such authentication mechanisms MAY rely on the values of header fields not listed here.



[.* MUST .*]	[.* MAY .*]	
A transparent proxy MUST preserve the entity-length (section 7.2.2) of the entity-body, although it MAY change the transfer-length (section 4.4).



[.* MAY .*]	
If the status code is 206 (Partial Content) and the ETag or Last-Modified headers match exactly, the cache MAY combine the contents stored in the cache entry with the new contents received in the response and use the result as the entity-body of this outgoing response, (see 13.5.4).



[.* MUST .*]	
 - any stored Warning headers with warn-code 1xx (see section 14.46) MUST be deleted from the cache entry and the forwarded response.



[.* MUST .*]	
 - any stored Warning headers with warn-code 2xx MUST be retained in the cache entry and the forwarded response.



[.* MUST .*]	
 - any end-to-end headers provided in the 304 or 206 response MUST replace the corresponding headers from the cache entry.



[.* MUST .*]	
 Unless the cache decides to remove the cache entry, it MUST also replace the end-to-end headers stored with the cache entry with corresponding headers received in the incoming response, except for Warning headers as described immediately above.



[.* MUST .*]	
If a header field- name in the incoming response matches more than one header in the cache entry, all such old headers MUST be replaced.



[.* MAY .*]	
 If a cache has a stored non-empty set of subranges for an entity, and an incoming response transfers another subrange, the cache MAY combine the new subrange with the existing set if both the following conditions are met:



[.* MUST .*]	
 If either requirement is not met, the cache MUST use only the most recent partial response (based on the Date values transmitted with every response, and using the incoming response if these values are equal or missing), and MUST discard the other partial information.



[.* SHOULD .*]	
 A server SHOULD use the Vary header field to inform a cache of what request-header fields were used to select among multiple representations of a cacheable response subject to server-driven negotiation.



[.* MUST .*]	
 When the cache receives a subsequent request whose Request-URI specifies one or more cache entries including a Vary header field, the cache MUST NOT use such a cache entry to construct a response to the new request unless all of the selecting request-headers present in the new request match the corresponding stored request-headers in the original request.



[.* MUST .*]	
 If the selecting request header fields for the cached entry do not match the selecting request header fields of the new request, then the cache MUST NOT use a cached entry to satisfy the request unless it first relays the new request to the origin server in a conditional request and the server responds with 304 (Not Modified), including an entity tag or Content-Location that indicates the entity to be used.



[.* SHOULD .*]	
 If an entity tag was assigned to a cached representation, the forwarded request SHOULD be conditional and include the entity tags in an If-None-Match header field from all its cache entries for the resource.



[.* SHOULD .*]	[.* MUST .*]	
If the entity-tag of the new response matches that of an existing entry, the new response SHOULD be used to update the header fields of the existing entry, and the result MUST be returned to the client.



[.* SHOULD .*]	
 If any of the existing cache entries contains only partial content for the associated entity, its entity-tag SHOULD NOT be included in the If-None-Match header field unless the request is for a range that would be fully satisfied by that entry.



[.* SHOULD .*]	
 If a cache receives a successful response whose Content-Location field matches that of an existing cache entry for the same Request- ]URI, whose entity-tag differs from that of the existing entry, and whose Date is more recent than that of the existing entry, the existing entry SHOULD NOT be returned in response to future requests and SHOULD be deleted from the cache.



[.* SHOULD .*]	
Accessibility in this case SHOULD be enforced by appropriate security mechanisms.



[.* MAY .*]	
 A cache that receives an incomplete response (for example, with fewer bytes of data than specified in a Content-Length header) MAY store the response.



[.* MUST .*]	
However, the cache MUST treat this as a partial response.



[.* MAY .*]	
Partial responses MAY be combined as described in section 13.5.4; the result might be a full response or might still be partial.



[.* MUST .*]	
A cache MUST NOT return a partial response to a client without explicitly marking it as such, using the 206 (Partial Content) status code.



[.* MUST .*]	
A cache MUST NOT return a partial response using a status code of 200 (OK).



[.* MAY .*]	
 If a cache receives a 5xx response while attempting to revalidate an entry, it MAY either forward this response to the requesting client, or act as if the server failed to respond.



[.* MAY .*]	
In the latter case, it MAY return a previously received response unless the cached entry includes the "must-revalidate" cache-control directive (see section 14.9).



[.* SHOULD .*]	
 Unless the origin server explicitly prohibits the caching of their responses, the application of GET and HEAD methods to any resources SHOULD NOT have side effects that would lead to erroneous behavior if these responses are taken from a cache.



[.* MAY .*]	
They MAY still have side effects, but a cache is not required to consider such side effects in its caching decisions.



[.* MUST .*]	
in the rel_path part) to perform operations with significant side effects, caches MUST NOT treat responses to such URIs as fresh unless the server provides an explicit expiration time.



[.* SHOULD .*]	
This specifically means that responses from HTTP/1.0 servers for such URIs SHOULD NOT be taken from a cache.



[.* MUST .*]	
 Some HTTP methods MUST cause a cache to invalidate an entity.



[.* MUST .*]	
 In order to prevent denial of service attacks, an invalidation based on the URI in a Location or Content-Location header MUST only be performed if the host part is the same as in the Request-URI.



[.* SHOULD .*]	
 A cache that passes through requests for methods it does not understand SHOULD invalidate any entities referred to by the Request-URI.



[.* MUST .*]	
 All methods that might be expected to cause modifications to the origin server's resources MUST be written through to the origin server.



[.* MUST .*]	
A cache MUST NOT reply to such a request from a client before having transmitted the request to the inbound server, and having received a corresponding response from the inbound server.



[.* SHOULD .*]	
 If a new cacheable (see sections 14.9.2, 13.2.5, 13.2.6 and 13.8) response is received from a resource while any existing responses for the same resource are cached, the cache SHOULD use the new response to reply to the current request.



[.* MAY .*]	
It MAY insert it into cache storage and MAY, if it meets all other requirements, use it to respond to any future requests that would previously have caused the old response to be returned.



[.* SHOULD .*]	
In particular history mechanisms SHOULD NOT try to show a semantically transparent view of the current state of a resource.



[.* SHOULD .*]	
If the entity is still in storage, a history mechanism SHOULD display it even if the entity has expired, unless the user has specifically configured the agent to refresh expired history documents.



[.* MAY .*]	
The media-range MAY include media type parameters that are applicable to that range.



[.* MAY .*]	
 Each media-range MAY be followed by one or more accept-params, beginning with the "q" parameter for indicating a relative quality factor.



[.* SHOULD .*]	
 SHOULD be interpreted as "I prefer audio/basic, but send me any audio type if it is the best available after an 80% mark-down in quality."



[.* SHOULD .*]	
If an Accept header field is present, and if the server cannot send a response which is acceptable according to the combined Accept field value, then the server SHOULD send a 406 (not acceptable) response.



[.* MAY .*]	
Each charset MAY be given an associated quality value which represents the user's preference for that charset.



[.* SHOULD .*]	
If an Accept-Charset header is present, and if the server cannot send a response which is acceptable according to the Accept-Charset header, then the server SHOULD send an error response with the 406 (not acceptable) status code, though the sending of an unacceptable response is also allowed.



[.* SHOULD .*]	
 If an Accept-Encoding field is present in a request, and if the server cannot send a response which is acceptable according to the Accept-Encoding header, then the server SHOULD send an error response with the 406 (Not Acceptable) status code.



[.* MAY .*]	
 If no Accept-Encoding field is present in a request, the server MAY assume that the client will accept any content coding.



[.* SHOULD .*]	
In this case, if "identity" is one of the available content-codings, then the server SHOULD use the "identity" content-coding, unless it has additional information that a different content-coding is meaningful to the client.



[.* MAY .*]	
 Each language-range MAY be given an associated quality value which represents an estimate of the user's preference for the languages specified by that range.



[.* SHOULD .*]	
If no Accept-Language header is present in the request, the server SHOULD assume that all languages are equally acceptable.



[.* MUST .*]	
If the choice is not made available, then the Accept-Language header field MUST NOT be given in the request.



[.* MAY .*]	
 Origin servers that accept byte-range requests MAY send



[.* MAY .*]	
Clients MAY generate byte-range requests without having received this header for the resource involved.



[.* MAY .*]	
 Servers that do not accept any kind of range request for a resource MAY send



[.* MUST .*]	
 If a cache receives a value larger than the largest positive integer it can represent, or if any of its age calculations overflows, it MUST transmit an Age header with a value of 2147483648 (2^31).



[.* MUST .*]	
An HTTP/1.1 server that includes a cache MUST include an Age header field in every response generated from its own cache.



[.* SHOULD .*]	
Caches SHOULD use an arithmetic type of at least 31 bits of range.



[.* MUST .*]	
An Allow header field MUST be present in a 405 (Method Not Allowed) response.



[.* SHOULD .*]	
However, the indications given by the Allow header field value SHOULD be followed.



[.* MAY .*]	
 The Allow header field MAY be provided with a PUT request to recommend the methods to be supported by the new or modified resource.



[.* SHOULD .*]	
The server is not required to support these methods and SHOULD include an Allow header in the response giving the actual supported methods.



[.* MUST .*]	
A proxy MUST NOT modify the Allow header field even if it does not understand all the methods specified, since the user agent might have other means of communicating with the origin server.



[.* SHOULD .*]	
If a request is authenticated and a realm specified, the same credentials SHOULD be valid for all other requests within this realm (assuming that the authentication scheme itself does not require otherwise, such as credentials that vary according to a challenge value or using synchronized clocks).



[.* MUST .*]	
 When a shared cache (see section 13.7) receives a request containing an Authorization field, it MUST NOT return the corresponding response as a reply to any other request, unless one of the following specific exceptions holds:



[.* MAY .*]	
If the response includes the "s-maxage" cache-control directive, the cache MAY use that response in replying to a subsequent request.



[.* MUST .*]	
But (if the specified maximum age has passed) a proxy cache MUST first revalidate it with the origin server, using the request-headers from the new request to allow the origin server to authenticate the new request.



[.* MUST .*]	
If the response includes "s- maxage=0", the proxy MUST always revalidate it before re-using it.



[.* MAY .*]	
If the response includes the "must-revalidate" cache-control directive, the cache MAY use that response in replying to a subsequent request.



[.* MUST .*]	
But if the response is stale, all caches MUST first revalidate it with the origin server, using the request-headers from the new request to allow the origin server to authenticate the new request.



[.* MAY .*]	
If the response includes the "public" cache-control directive, it MAY be returned in reply to any subsequent request.



[.* MUST .*]	
 The Cache-Control general-header field is used to specify directives that MUST be obeyed by all caching mechanisms along the request/response chain.



[.* MUST .*]	
 Cache directives MUST be passed through by a proxy or gateway application, regardless of their significance to that application, since the directives might be applicable to all recipients along the request/response chain.



[.* MAY .*]	
 public Indicates that the response MAY be cached by any cache, even if it would normally be non-cacheable or cacheable only within a non- shared cache.



[.* MUST .*]	
 private Indicates that all or part of the response message is intended for a single user and MUST NOT be cached by a shared cache.



[.* MAY .*]	
A private (non-shared) cache MAY cache the response.



[.* MUST .*]	
 no-cache If the no-cache directive does not specify a field-name, then a cache MUST NOT use the response to satisfy a subsequent request without successful revalidation with the origin server.



[.* MAY .*]	
 If the no-cache directive does specify one or more field-names, then a cache MAY use the response to satisfy a subsequent request, subject to any other restrictions on caching.



[.* MUST .*]	
However, the specified field-name(s) MUST NOT be sent in the response to a subsequent request without successful revalidation with the origin server.



[.* MAY .*]	
The no-store directive applies to the entire message, and MAY be sent either in a response or in a request.



[.* MUST .*]	
If sent in a request, a cache MUST NOT store any part of either this request or any response to it.



[.* MUST .*]	
If sent in a response, a cache MUST NOT store any part of either this response or the request that elicited it.



[.* MUST .*]	
"MUST NOT store" in this context means that the cache MUST NOT intentionally store the information in non-volatile storage, and MUST make a best-effort attempt to remove the information from volatile storage as promptly as possible after forwarding it.



[.* MAY .*]	
History buffers MAY store such responses as part of their normal operation.



[.* MAY .*]	
 The expiration time of an entity MAY be specified by the origin server using the Expires header (see section 14.21).



[.* MAY .*]	
Alternatively, it MAY be specified using the max-age directive in a response.



[.* SHOULD .*]	
If an HTTP/1.1 cache receives such a response, and the response does not include a Cache-Control header field, it SHOULD consider the response to be non-cacheable in order to retain compatibility with HTTP/1.0 servers.



[.* MAY .*]	
An origin server wishing to use a cache-control directive that restricts, but does not prevent, caching by an HTTP/1.1-compliant cache MAY exploit the requirement that the max-age directive overrides the Expires header, and the fact that pre-HTTP/1.1-compliant caches do not observe the max-age directive.



[.* MAY .*]	
These directives MAY be specified on a request:



[.* MUST .*]	
 If a cache returns a stale response, either because of a max-stale directive on a request, or because the cache is configured to override the expiration time of a response, the cache MUST attach a Warning header to the stale response, using Warning 110 (Response is stale).



[.* MAY .*]	
A cache MAY be configured to return stale responses without validation, but only if this does not conflict with any "MUST"-level requirements concerning cache validation (e.g,, a "must-revalidate" cache-control directive).



[.* MUST .*]	
Field names MUST NOT be included with the no-cache directive in a request.



[.* MUST .*]	
The server MUST NOT use a cached copy when responding to such a request.



[.* MAY .*]	
In this case, the cache MAY use either validator in making its own request without affecting semantic transparency.



[.* SHOULD .*]	
 If a request includes the no-cache directive, it SHOULD NOT include min-fresh, max-stale, or max-age.



[.* SHOULD .*]	
If it receives this directive, a cache SHOULD either respond using a cached entry that is consistent with the other constraints of the request, or respond with a 504 (Gateway Timeout) status.



[.* MAY .*]	
However, if a group of caches is being operated as a unified system with good internal connectivity, such a request MAY be forwarded within that group of caches.



[.* MAY .*]	
 must-revalidate Because a cache MAY be configured to ignore a server's specified expiration time, and because a client request MAY include a max- stale directive (which has a similar effect), the protocol also includes a mechanism for the origin server to require revalidation of a cache entry on any subsequent use.



[.* MUST .*]	
When the must-revalidate directive is present in a response received by a cache, that cache MUST NOT use the entry after it becomes stale to respond to a subsequent request without first revalidating it with the origin server.



[.* MUST .*]	
(I.e., the cache MUST do an end-to-end revalidation every time, if, based solely on the origin server's Expires or max-age value, the cached response is stale.)



[.* MUST .*]	
In all circumstances an HTTP/1.1 cache MUST obey the must-revalidate directive; in particular, if the cache cannot reach the origin server for any reason, it MUST generate a 504 (Gateway Timeout) response.



[.* SHOULD .*]	
 Servers SHOULD send the must-revalidate directive if and only if failure to revalidate a request on the entity could result in incorrect operation, such as a silently unexecuted financial transaction.



[.* MUST .*]	
Recipients MUST NOT take any automated action that violates this directive, and MUST NOT automatically provide an unvalidated copy of the entity if revalidation fails.



[.* MUST .*]	[.* MAY .*]	
 Although this is not recommended, user agents operating under severe connectivity constraints MAY violate this directive but, if so, MUST explicitly warn the user that an unvalidated response has been provided.



[.* SHOULD .*]	[.* MUST .*]	
The warning MUST be provided on each unvalidated access, and SHOULD require explicit user confirmation.



[.* MUST .*]	
 Therefore, if a message includes the no-transform directive, an intermediate cache or proxy MUST NOT change those headers that are listed in section 13.5.2 as being subject to the no-transform directive.



[.* MUST .*]	
This implies that the cache or proxy MUST NOT change any aspect of the entity-body that is specified by these headers, including the value of the entity-body itself.



[.* MAY .*]	
Informational extensions (those which do not require a change in cache behavior) MAY be added without changing the semantics of other directives.



[.* MUST .*]	
Unrecognized cache-directives MUST be ignored; it is assumed that any cache-directive likely to be unrecognized by an HTTP/1.1 cache will be combined with standard directives (or the response's default cacheability) such that the cache behavior will remain minimally correct even if the cache does not understand the extension(s).



[.* MUST .*]	
 The Connection general-header field allows the sender to specify options that are desired for that particular connection and MUST NOT be communicated by proxies over further connections.



[.* MUST .*]	
 HTTP/1.1 proxies MUST parse the Connection header field before a message is forwarded and, for each connection-token in this field, remove any header field(s) from the message with the same name as the connection-token.



[.* MUST .*]	
 Message headers listed in the Connection header MUST NOT include end-to-end headers, such as Cache-Control.



[.* SHOULD .*]	
 in either the request or the response header fields indicates that the connection SHOULD NOT be considered `persistent' (section 8.1) after the current request/response is complete.



[.* MUST .*]	
 HTTP/1.1 applications that do not support persistent connections MUST include the "close" connection option in every message.



[.* MAY .*]	
However, a non-transparent proxy MAY modify the content-coding if the new coding is known to be acceptable to the recipient, unless the "no-transform" cache-control directive is present in the message.



[.* MUST .*]	
 If the content-coding of an entity is not "identity", then the response MUST include a Content-Encoding entity-header (section 14.11) that lists the non-identity content-coding(s) used.



[.* SHOULD .*]	
 If the content-coding of an entity in a request message is not acceptable to the origin server, the server SHOULD respond with a status code of 415 (Unsupported Media Type).



[.* MUST .*]	
 If multiple encodings have been applied to an entity, the content codings MUST be listed in the order in which they were applied.



[.* MAY .*]	
Additional information about the encoding parameters MAY be provided by other entity-header fields not defined by this specification.



[.* MAY .*]	
 Multiple languages MAY be listed for content that is intended for multiple audiences.



[.* MAY .*]	
 Content-Language MAY be applied to any media type -- it is not limited to textual documents.



[.* SHOULD .*]	
 Applications SHOULD use this field to indicate the transfer-length of the message-body, unless this is prohibited by the rules in section 4.4.



[.* SHOULD .*]	
In HTTP, it SHOULD be sent whenever the message's length can be determined prior to being transferred, unless this is prohibited by the rules in section 4.4.



[.* MAY .*]	
 The Content-Location entity-header field MAY be used to supply the resource location for the entity enclosed in the message when that entity is accessible from a location separate from the requested resource's URI.



[.* SHOULD .*]	
A server SHOULD provide a Content-Location for the variant corresponding to the response entity; especially in the case where a resource has multiple entities associated with it, and those entities actually have separate locations by which they might be individually accessed, the server SHOULD provide a Content-Location for the particular variant which is returned.



[.* MAY .*]	
Future requests MAY specify the Content-Location URI as the request- URI if the desire is to identify the source of that particular entity.



[.* MAY .*]	
 The Content-MD5 header field MAY be generated by an origin server or client to function as an integrity check of the entity-body.



[.* MUST .*]	[.* MAY .*]	
Only origin servers or clients MAY generate the Content-MD5 header field; proxies and gateways MUST NOT generate it, as this would defeat its value as an end-to-end integrity check.



[.* MAY .*]	
Any recipient of the entity- body, including gateways and proxies, MAY check that the digest value in this header field matches that of the entity-body as received.



[.* MUST .*]	
If the message is received with a transfer-encoding, that encoding MUST be removed prior to checking the Content-MD5 value against the received entity.



[.* MAY .*]	
The entity-body for composite types MAY contain many body-parts, each with its own MIME and HTTP headers (including Content-MD5, Content-Transfer-Encoding, and Content-Encoding headers).



[.* MUST .*]	
 Conversion of all line breaks to CRLF MUST NOT be done before computing or checking the digest: the line break convention used in the text actually transmitted MUST be left unaltered when computing the digest.



[.* SHOULD .*]	
 The header SHOULD indicate the total length of the full entity-body, unless this length is unknown or difficult to determine.



[.* MUST .*]	
 Unlike byte-ranges-specifier values (see section 14.35.1), a byte- range-resp-spec MUST only specify one range, and MUST contain absolute byte positions for both the first and last byte of the range.



[.* MUST .*]	
The recipient of an invalid byte-content-range- spec MUST ignore it and any content transferred along with it.



[.* SHOULD .*]	
 A server sending a response with status code 416 (Requested range not satisfiable) SHOULD include a Content-Range field with a byte-range- resp-spec of "*".



[.* MUST .*]	
A response with status code 206 (Partial Content) MUST NOT include a Content-Range field with a byte-range- resp-spec of "*".



[.* MUST .*]	
 A response to a request for a single range MUST NOT be sent using the multipart/byteranges media type.



[.* MAY .*]	
A response to a request for multiple ranges, whose result is a single range, MAY be sent as a multipart/byteranges media type with one part.



[.* MUST .*]	
A client that cannot decode a multipart/byteranges message MUST NOT ask for multiple byte-ranges in a single request.



[.* SHOULD .*]	
 When a client requests multiple byte-ranges in one request, the server SHOULD return them in the order that they appeared in the request.



[.* SHOULD .*]	
If the server ignores a byte-range-spec because it is syntactically invalid, the server SHOULD treat the request as if the invalid Range header field did not exist.



[.* SHOULD .*]	
 If the server receives a request (other than one including an If- Range request-header field) with an unsatisfiable Range request- header field (that is, all of whose byte-range-spec values have a first-byte-pos value greater than the current length of the selected resource), it SHOULD return a response code of 416 (Requested range not satisfiable) (section 10.4.17).



[.* MUST .*]	
The field value is an HTTP-date, as described in section 3.3.1; it MUST be sent in RFC 1123 [8]-date format.



[.* MUST .*]	
 Origin servers MUST include a Date header field in all responses, except in these cases: 1.



[.* MAY .*]	
If the response status code is 100 (Continue) or 101 (Switching Protocols), the response MAY include a Date header field, at the server's option.



[.* MUST .*]	
If the server does not have a clock that can provide a reasonable approximation of the current time, its responses MUST NOT include a Date header field.



[.* MUST .*]	
In this case, the rules in section 14.18.1 MUST be followed.



[.* MUST .*]	
 A received message that does not have a Date header field MUST be assigned one by the recipient if the message will be cached by that recipient or gatewayed via a protocol which requires a Date.



[.* MUST .*]	
An HTTP implementation without a clock MUST NOT cache responses without revalidating them on every use.



[.* SHOULD .*]	
An HTTP cache, especially a shared cache, SHOULD use a mechanism, such as NTP [28], to synchronize its clock with a reliable external standard.



[.* SHOULD .*]	
 Clients SHOULD only send a Date header field in messages that include an entity-body, as in the case of the PUT and POST requests, and even then it is optional.



[.* MUST .*]	
A client without a clock MUST NOT send a Date header field in a request.



[.* SHOULD .*]	
 The HTTP-date sent in a Date header SHOULD NOT represent a date and time subsequent to the generation of the message.



[.* SHOULD .*]	
It SHOULD represent the best available approximation of the date and time of message generation, unless the implementation has no means of generating a reasonably accurate date and time.



[.* MUST .*]	
An origin server without a clock MUST NOT assign Expires or Last- Modified values to a response, unless these values were associated with the resource by a system or user with a reliable clock.



[.* MAY .*]	
It MAY assign an Expires value that is known, at or before server configuration time, to be in the past (this allows "pre-expiration" of responses without storing separate Expires values for each resource).



[.* MAY .*]	
The entity tag MAY be used for comparison with other entities from the same resource (see section 13.3.3).



[.* MUST .*]	
 A server that does not understand or is unable to comply with any of the expectation values in the Expect field of a request MUST respond with appropriate error status.



[.* MUST .*]	
The server MUST respond with a 417 (Expectation Failed) status if any of the expectations cannot be met or, if there are other problems with the request, some other 4xx status.



[.* MUST .*]	
If a server receives a request containing an Expect field that includes an expectation-extension that it does not support, it MUST respond with a 417 (Expectation Failed) status.



[.* MUST .*]	
The Expect mechanism is hop-by-hop: that is, an HTTP/1.1 proxy MUST return a 417 (Expectation Failed) status if it receives a request with an expectation that it cannot meet.



[.* MUST .*]	
However, the Expect request-header itself is end-to-end; it MUST be forwarded if the request is forwarded.



[.* MUST .*]	
 The format is an absolute date and time as defined by HTTP-date in section 3.3.1; it MUST be in RFC 1123 date format:



[.* MUST .*]	
 HTTP/1.1 clients and caches MUST treat other invalid date formats, especially including the value "0", as in the past (i.e., "already expired").



[.* SHOULD .*]	
HTTP/1.1 servers SHOULD NOT send Expires dates more than one year in the future.



[.* SHOULD .*]	
 The From request-header field, if given, SHOULD contain an Internet e-mail address for the human user who controls the requesting user agent.



[.* SHOULD .*]	
The address SHOULD be machine-usable, as defined by "mailbox" in RFC 822 [9] as updated by RFC 1123 [8]:



[.* MAY .*]	
 This header field MAY be used for logging purposes and as a means for identifying the source of invalid or unwanted requests.



[.* SHOULD .*]	
It SHOULD NOT be used as an insecure form of access protection.



[.* SHOULD .*]	
In particular, robot agents SHOULD include this header so that the person responsible for running the robot can be contacted if problems occur on the receiving end.



[.* MAY .*]	
 The Internet e-mail address in this field MAY be separate from the Internet host which issued the request.



[.* SHOULD .*]	
For example, when a request is passed through a proxy the original issuer's address SHOULD be used.



[.* SHOULD .*]	
 The client SHOULD NOT send the From header field without the user's approval, as it might conflict with the user's privacy interests or their site's security policy.



[.* MUST .*]	
The Host field value MUST represent the naming authority of the origin server or gateway given by the original URL.



[.* MUST .*]	
 A client MUST include a Host header field in all HTTP/1.1 request messages .



[.* MUST .*]	
If the requested URI does not include an Internet host name for the service being requested, then the Host header field MUST be given with an empty value.



[.* MUST .*]	
An HTTP/1.1 proxy MUST ensure that any request message it forwards does contain an appropriate Host header field that identifies the service being requested by the proxy.



[.* MUST .*]	
All Internet-based HTTP/1.1 servers MUST respond with a 400 (Bad Request) status code to any HTTP/1.1 request message which lacks a Host header field.



[.* MAY .*]	
 If any of the entity tags match the entity tag of the entity that would have been returned in the response to a similar GET request (without the If-Match header) on that resource, or if "*" is given and any current entity exists for that resource, then the server MAY perform the requested method as if the If-Match header field did not exist.



[.* MUST .*]	
 A server MUST use the strong comparison function (see section 13.3.3) to compare the entity tags in If-Match.



[.* MUST .*]	
 If none of the entity tags match, or if "*" is given and no current entity exists, the server MUST NOT perform the requested method, and MUST return a 412 (Precondition Failed) response.



[.* MUST .*]	
 If the request would, without the If-Match header field, result in anything other than a 2xx or 412 status, then the If-Match header MUST be ignored.



[.* SHOULD .*]	[.* MUST .*]	
 The meaning of "If-Match: *" is that the method SHOULD be performed if the representation selected by the origin server (or by a cache, possibly using the Vary mechanism, see section 14.44) exists, and MUST NOT be performed if the representation does not exist.



[.* MUST .*]	[.* MAY .*]	
 A request intended to update a resource (e.g,, a PUT) MAY include an If-Match header field to signal that the request method MUST NOT be applied if the entity corresponding to the If-Match value (a single entity tag) is no longer a representation of that resource.



[.* SHOULD .*]	
 c) If the variant has not been modified since a valid If- Modified-Since date, the server SHOULD return a 304 (Not Modified) response.



[.* MUST .*]	
 If any of the entity tags match the entity tag of the entity that would have been returned in the response to a similar GET request (without the If-None-Match header) on that resource, or if "*" is given and any current entity exists for that resource, then the server MUST NOT perform the requested method, unless required to do so because the resource's modification date fails to match that supplied in an If-Modified-Since header field in the request.



[.* SHOULD .*]	
Instead, if the request method was GET or HEAD, the server SHOULD respond with a 304 (Not Modified) response, including the cache- related header fields (particularly ETag) of one of the entities that matched.



[.* MUST .*]	
For all other request methods, the server MUST respond with a status of 412 (Precondition Failed).



[.* MUST .*]	[.* MAY .*]	
If none of the entity tags match, then the server MAY perform the requested method as if the If-None-Match header field did not exist, but MUST also ignore any If-Modified-Since header field(s) in the request.



[.* MUST .*]	
That is, if no entity tags match, then the server MUST NOT return a 304 (Not Modified) response.



[.* MUST .*]	
 If the request would, without the If-None-Match header field, result in anything other than a 2xx or 304 status, then the If-None-Match header MUST be ignored.



[.* SHOULD .*]	[.* MUST .*]	
 The meaning of "If-None-Match: *" is that the method MUST NOT be performed if the representation selected by the origin server (or by a cache, possibly using the Vary mechanism, see section 14.44) exists, and SHOULD be performed if the representation does not exist.



[.* MAY .*]	
 If-Range = "If-Range" ":" ( entity-tag | HTTP-date ) If the client has no entity tag for an entity, but does have a Last- Modified date, it MAY use that date in an If-Range header.



[.* SHOULD .*]	[.* MUST .*]	
The If-Range header SHOULD only be used together with a Range header, and MUST be ignored if the request does not include a Range header, or if the server does not support the sub-range operation.



[.* SHOULD .*]	
 If the entity tag given in the If-Range header matches the current entity tag for the entity, then the server SHOULD provide the specified sub-range of the entity using a 206 (Partial content) response.



[.* SHOULD .*]	
If the entity tag does not match, then the server SHOULD return the entire entity using a 200 (OK) response.



[.* SHOULD .*]	
If the requested resource has not been modified since the time specified in this field, the server SHOULD perform the requested operation as if the If-Unmodified-Since header were not present.



[.* MUST .*]	
 If the requested variant has been modified since the specified time, the server MUST NOT perform the requested operation, and MUST return a 412 (Precondition Failed).



[.* SHOULD .*]	
 If the request normally (i.e., without the If-Unmodified-Since header) would result in anything other than a 2xx or 412 status, the If-Unmodified-Since header SHOULD be ignored.



[.* MUST .*]	
 An origin server MUST NOT send a Last-Modified date which is later than the server's time of message origination.



[.* MUST .*]	
In such cases, where the resource's last modification would indicate some time in the future, the server MUST replace that date with the message origination date.



[.* SHOULD .*]	
 An origin server SHOULD obtain the Last-Modified value of the entity as close as possible to the time that it generates the Date value of its response.



[.* SHOULD .*]	
 HTTP/1.1 servers SHOULD send Last-Modified whenever feasible.



[.* SHOULD .*]	
For 3xx responses, the location SHOULD indicate the server's preferred URI for automatic redirection to the resource.



[.* MUST .*]	
 Each proxy or gateway recipient of a TRACE or OPTIONS request containing a Max-Forwards header field MUST check and update its value prior to forwarding the request.



[.* MUST .*]	
If the received value is zero (0), the recipient MUST NOT forward the request; instead, it MUST respond as the final recipient.



[.* MUST .*]	
If the received Max-Forwards value is greater than zero, then the forwarded message MUST contain an updated Max-Forwards field with a value decremented by one (1).



[.* MAY .*]	
 The Max-Forwards header field MAY be ignored for all other methods defined by this specification and for any extension methods for which it is not explicitly referred to as part of that method definition.



[.* MAY .*]	
All pragma directives specify optional behavior from the viewpoint of the protocol; however, some systems MAY require that behavior be consistent with the directives.



[.* SHOULD .*]	
 When the no-cache directive is present in a request message, an application SHOULD forward the request toward the origin server even if it has a cached copy of what is being requested.



[.* SHOULD .*]	
Clients SHOULD include both header fields when a no-cache request is sent to a server not known to be HTTP/1.1 compliant.



[.* MUST .*]	
Pragma directives MUST be passed through by a proxy or gateway application, regardless of their significance to that application, since the directives might be applicable to all recipients along the request/response chain.



[.* SHOULD .*]	
It is not possible to specify a pragma for a specific recipient; however, any pragma directive not relevant to a recipient SHOULD be ignored by that recipient.



[.* SHOULD .*]	
 HTTP/1.1 caches SHOULD treat "Pragma: no-cache" as if the client had sent "Cache-Control: no-cache".



[.* MUST .*]	
 The Proxy-Authenticate response-header field MUST be included as part of a 407 (Proxy Authentication Required) response.



[.* SHOULD .*]	
Unlike WWW-Authenticate, the Proxy-Authenticate header field applies only to the current connection and SHOULD NOT be passed on to downstream clients.



[.* MAY .*]	
A proxy MAY relay the credentials from the client request to the next proxy if that is the mechanism by which the proxies cooperatively authenticate a given request.



[.* MAY .*]	
 A byte range operation MAY specify a single range of bytes, or a set of ranges within a single entity.



[.* MUST .*]	
 If the last-byte-pos value is present, it MUST be greater than or equal to the first-byte-pos in that byte-range-spec, or the byte- range-spec is syntactically invalid.



[.* MUST .*]	
The recipient of a byte-range- set that includes one or more syntactically invalid byte-range-spec values MUST ignore the header field that includes that byte-range- set.



[.* SHOULD .*]	
If the byte-range-set is unsatisfiable, the server SHOULD return a response with a status of 416 (Requested range not satisfiable).



[.* SHOULD .*]	
Otherwise, the server SHOULD return a response with a status of 206 (Partial Content) containing the satisfiable ranges of the entity-body.



[.* MAY .*]	
 HTTP retrieval requests using conditional or unconditional GET methods MAY request one or more sub-ranges of the entity, instead of the entire entity, using the Range request header, which applies to the entity returned as the result of the request:



[.* MAY .*]	
 Range = "Range" ":" ranges-specifier A server MAY ignore the Range header.



[.* SHOULD .*]	
 If a proxy that supports ranges receives a Range request, forwards the request to an inbound server, and receives an entire entity in reply, it SHOULD only return the requested range to its client.



[.* SHOULD .*]	
It SHOULD store the entire received response in its cache if that is consistent with its cache allocation policies.



[.* MUST .*]	
The Referer field MUST NOT be sent if the Request-URI was obtained from a source that does not have its own URI, such as input from the user keyboard.



[.* SHOULD .*]	
 Referer: http://www.w3.org/hypertext/DataSources/Overview.html If the field value is a relative URI, it SHOULD be interpreted relative to the Request-URI.



[.* MUST .*]	
The URI MUST NOT include a fragment.



[.* MAY .*]	
This field MAY also be used with any 3xx (Redirection) response to indicate the minimum time the user-agent is asked wait before issuing the redirected request.



[.* MUST .*]	
 If the response is being forwarded through a proxy, the proxy application MUST NOT modify the Server response-header.



[.* SHOULD .*]	
Instead, it SHOULD include a Via field (as described in section 14.45).



[.* MUST .*]	
Therefore, the keyword MUST be supplied within a Connection header field (section 14.10) whenever TE is present in an HTTP/1.1 message.



[.* SHOULD .*]	
 An HTTP/1.1 message SHOULD include a Trailer header field in a message using chunked transfer-coding with a non-empty trailer.



[.* SHOULD .*]	
 If no Trailer header field is present, the trailer SHOULD NOT include any header fields.



[.* MUST .*]	
 Message header fields listed in the Trailer header field MUST NOT include the following header fields:



[.* MUST .*]	
 Transfer-Encoding: chunked If multiple encodings have been applied to an entity, the transfer- codings MUST be listed in the order in which they were applied.



[.* MAY .*]	
Additional information about the encoding parameters MAY be provided by other entity-header fields not defined by this specification.



[.* MUST .*]	
The server MUST use the Upgrade header field within a 101 (Switching Protocols) response to indicate which protocol(s) are being switched.



[.* MUST .*]	
The capabilities and nature of the application-layer communication after the protocol change is entirely dependent upon the new protocol chosen, although the first action after changing the protocol MUST be a response to the initial HTTP request containing the Upgrade header field.



[.* MUST .*]	
Therefore, the upgrade keyword MUST be supplied within a Connection header field (section 14.10) whenever Upgrade is present in an HTTP/1.1 message.



[.* SHOULD .*]	
User agents SHOULD include this field with requests.



[.* SHOULD .*]	
 An HTTP/1.1 server SHOULD include a Vary header field with any cacheable response that is subject to server-driven negotiation.



[.* MAY .*]	
A server MAY include a Vary header field with a non-cacheable response that is subject to server-driven negotiation, since this might provide the user agent with useful information about the dimensions over which the response varies at the time of the response.



[.* MAY .*]	
A cache MAY assume that the same selection will be made for future requests with the same values for the listed field names, for the duration of time for which the response is fresh.



[.* MUST .*]	
The "*" value MUST NOT be generated by a proxy server; it may only be generated by an origin server.



[.* MUST .*]	
 The Via general-header field MUST be used by gateways and proxies to indicate the intermediate protocols and recipients between the user agent and the server on requests, and between the origin server and the client on responses.



[.* MAY .*]	
However, if the real host is considered to be sensitive information, it MAY be replaced by a pseudonym.



[.* MAY .*]	
If the port is not given, it MAY be assumed to be the default port of the received-protocol.



[.* MUST .*]	
Each recipient MUST append its information such that the end result is ordered according to the sequence of forwarding applications.



[.* MAY .*]	
 Comments MAY be used in the Via header field to identify the software of the recipient proxy or gateway, analogous to the User-Agent and Server header fields.



[.* MAY .*]	
However, all comments in the Via field are optional and MAY be removed by any recipient prior to forwarding the message.



[.* SHOULD .*]	
 Proxies and gateways used as a portal through a network firewall SHOULD NOT, by default, forward the names and ports of hosts within the firewall region.



[.* SHOULD .*]	
This information SHOULD only be propagated if explicitly enabled.



[.* SHOULD .*]	
If not enabled, the received-by host of any host behind the firewall SHOULD be replaced by an appropriate pseudonym for that host.



[.* MAY .*]	
 For organizations that have strong privacy requirements for hiding internal structures, a proxy MAY combine an ordered subsequence of Via header field entries with identical received-protocol values into a single such entry.



[.* SHOULD .*]	
 Via: 1.0 ricky, 1.1 mertz, 1.0 lucy Applications SHOULD NOT combine multiple entries unless they are all under the same organizational control and the hosts have already been replaced by pseudonyms.



[.* MUST .*]	
Applications MUST NOT combine entries which have different received-protocol values.



[.* MAY .*]	
 A response MAY carry more than one Warning header.



[.* SHOULD .*]	
 The warn-text SHOULD be in a natural language and character set that is most likely to be intelligible to the human user receiving the response.



[.* MAY .*]	
This decision MAY be based on any available knowledge, such as the location of the cache or user, the Accept-Language field in a request, the Content-Language field in a response, etc.



[.* MUST .*]	
 If a character set other than ISO-8859-1 is used, it MUST be encoded in the warn-text using the method described in RFC 2047 [14].



[.* SHOULD .*]	
New Warning headers SHOULD be added after any existing Warning headers.



[.* MUST .*]	
A cache MUST NOT delete any Warning header that it received with a message.



[.* SHOULD .*]	
However, if a cache successfully validates a cache entry, it SHOULD remove any Warning headers previously attached to that entry except as specified for specific Warning codes.



[.* MUST .*]	
It MUST then add any Warning headers received in the validating response.



[.* SHOULD .*]	
If it is not possible to inform the user of all of the warnings, the user agent SHOULD follow these heuristics:



[.* SHOULD .*]	
 Systems that generate multiple Warning headers SHOULD order them with this user agent behavior in mind.



[.* MUST .*]	
 110 Response is stale MUST be included whenever the returned response is stale.



[.* MUST .*]	
 111 Revalidation failed MUST be included if a cache returns a stale response because an attempt to revalidate the response failed, due to an inability to reach the server.



[.* SHOULD .*]	
 112 Disconnected operation SHOULD be included if the cache is intentionally disconnected from the rest of the network for a period of time.



[.* MUST .*]	
 113 Heuristic expiration MUST be included if the cache heuristically chose a freshness lifetime greater than 24 hours and the response's age is greater than 24 hours.



[.* MAY .*]	
 199 Miscellaneous warning The warning text MAY include arbitrary information to be presented to a human user, or logged.



[.* MUST .*]	
A system receiving this warning MUST NOT take any automated action, besides presenting the warning to the user.



[.* MUST .*]	
214 Transformation applied MUST be added by an intermediate cache or proxy if it applies any transformation changing the content-coding (as specified in the Content-Encoding header) or media-type (as specified in the Content-Type header) of the response, or the entity-body of the response, unless this Warning code already appears in the response.



[.* MAY .*]	
 299 Miscellaneous persistent warning The warning text MAY include arbitrary information to be presented to a human user, or logged.



[.* MUST .*]	
A system receiving this warning MUST NOT take any automated action.



[.* MUST .*]	
 If an implementation sends a message with one or more Warning headers whose version is HTTP/1.0 or lower, then the sender MUST include in each warning-value a warn-date that matches the date in the response.



[.* MUST .*]	
 If an implementation receives a message with a warning-value that includes a warn-date, and that warn-date is different from the Date value in the response, then that warning-value MUST be deleted from the message before storing, forwarding, or using it.



[.* MUST .*]	
If all of the warning-values are deleted for this reason, the Warning header MUST be deleted as well.



[.* MUST .*]	
 The WWW-Authenticate response-header field MUST be included in 401 (Unauthorized) response messages.



[.* SHOULD .*]	
), and SHOULD be very careful to prevent unintentional leakage of this information via the HTTP protocol to other sources.



[.* SHOULD .*]	
Therefore, applications SHOULD supply as much control over this information as possible to the provider of that information.



[.* SHOULD .*]	
Implementors SHOULD make the Server header field a configurable option.



[.* SHOULD .*]	
 Proxies which serve as a portal through a network firewall SHOULD take special precautions regarding the transfer of header information that identifies the hosts behind the firewall.



[.* SHOULD .*]	
In particular, they SHOULD remove, or replace with sanitized versions, any Via fields generated behind the firewall.



[.* SHOULD .*]	
 The information sent in the From field might conflict with the user's privacy interests or their site's security policy, and hence it SHOULD NOT be transmitted without the user being able to disable, enable, and modify the contents of the field.



[.* MUST .*]	
The user MUST be able to set the contents of this field within a user preference or application defaults configuration.



[.* SHOULD .*]	
 Clients SHOULD NOT include a Referer header field in a (non-secure) HTTP request if the referring page was transferred with a secure protocol.



[.* SHOULD .*]	
 Authors of services which use the HTTP protocol SHOULD NOT use GET based forms for the submission of sensitive data, because this will cause this data to be encoded in the Request-URI.



[.* SHOULD .*]	
General purpose user agents which provide a high degree of header configurability SHOULD warn users about the loss of privacy which can be involved.



[.* SHOULD .*]	
 Implementations of HTTP origin servers SHOULD be careful to restrict the documents returned by HTTP requests to be only those that were intended by the server administrators.



[.* MUST .*]	
If an HTTP server translates HTTP URIs directly into file system calls, the server MUST take special care not to serve files that were not intended to be delivered to HTTP clients.



[.* MUST .*]	
On such a system, an HTTP server MUST disallow any such construct in the Request-URI if it would otherwise allow access to a resource outside those intended to be accessible via the HTTP server.



[.* MUST .*]	
Similarly, files intended for reference only internally to the server (such as access control files, configuration files, and script code) MUST be protected from inappropriate retrieval, since they might contain sensitive information.



[.* SHOULD .*]	
 In particular, HTTP clients SHOULD rely on their name resolver for confirmation of an IP number/DNS name association, rather than caching the result of previous host name lookups.



[.* SHOULD .*]	
Many platforms already can cache host name lookups locally when appropriate, and they SHOULD be configured to do so.



[.* MUST .*]	
 If HTTP clients cache the results of host name lookups in order to achieve a performance improvement, they MUST observe the TTL information reported by DNS.



[.* MUST .*]	
 If a single server supports multiple organizations that do not trust one another, then it MUST check the values of Location and Content- Location headers in responses that are generated under control of said organizations to make sure that they do not attempt to invalidate resources over which they have no authority.



[.* SHOULD .*]	
 Clients SHOULD be tolerant in parsing the Status-Line and servers tolerant when parsing the Request-Line.



[.* SHOULD .*]	
In particular, they SHOULD accept any amount of SP or HT characters between fields, even though only a single SP is required.



[.* SHOULD .*]	
 The character set of an entity-body SHOULD be labeled as the lowest common denominator of the character codes used within that body, with the exception that not labeling the entity is preferred over labeling the entity with the labels US-ASCII or ISO-8859-1.



[.* SHOULD .*]	
 - HTTP/1.1 clients and caches SHOULD assume that an RFC-850 date which appears to be more than 50 years in the future is in fact in the past (this helps solve the "year 2000" problem).



[.* MUST .*]	[.* MAY .*]	
 - An HTTP/1.1 implementation MAY internally represent a parsed Expires date as earlier than the proper value, but MUST NOT internally represent a parsed Expires date as later than the proper value.



[.* MUST .*]	
 - All expiration-related calculations MUST be done in GMT.



[.* MUST .*]	
The local time zone MUST NOT influence the calculation or comparison of an age or expiration time.



[.* MUST .*]	
- If an HTTP header incorrectly carries a date value with a time zone other than GMT, it MUST be converted into GMT using the most conservative possible conversion.



[.* SHOULD .*]	
Proxies and gateways to strict MIME environments SHOULD be aware of these differences and provide the appropriate conversions where necessary.



[.* MAY .*]	
However, HTTP/1.1 messages MAY include a single MIME-Version general-header field to indicate what version of the MIME protocol was used to construct the message.



[.* SHOULD .*]	
 Where it is possible, a proxy or gateway from HTTP to a strict MIME environment SHOULD translate all line breaks within the text media types described in section 3.7.1 of this document to the RFC 2049 canonical form of CRLF.



[.* SHOULD .*]	
Proxies and gateways from other protocols SHOULD ensure that any Date header field present in a message conforms to one of the HTTP/1.1 formats and rewrite the date if necessary.



[.* MUST .*]	
Since this acts as a modifier on the media type, proxies and gateways from HTTP to MIME-compliant protocols MUST either change the value of the Content-Type header field or decode the entity-body before forwarding the message.



[.* MUST .*]	
Proxies and gateways from MIME-compliant protocols to HTTP MUST remove any non-identity CTE ("quoted-printable" or "base64") encoding prior to delivering the response message to an HTTP client.



[.* SHOULD .*]	
Such a proxy or gateway SHOULD label the data with an appropriate Content-Transfer-Encoding if doing so will improve the likelihood of safe transport over the destination protocol.



[.* MUST .*]	
Proxies/gateways MUST remove any transfer-coding prior to forwarding a message via a MIME-compliant protocol.



[.* SHOULD .*]	
 The receiving user agent SHOULD NOT respect any directory path information present in the filename-parm parameter, which is the only parameter believed to apply to HTTP implementations at this time.



[.* SHOULD .*]	
The filename SHOULD be treated as a terminal component only.



[.* MUST .*]	
 - Both clients and servers MUST support the Host request-header.



[.* MUST .*]	
 - A client that sends an HTTP/1.1 request MUST send a Host header.



[.* MUST .*]	
 - Servers MUST report a 400 (Bad Request) error if an HTTP/1.1 request does not include a Host request-header.



[.* MUST .*]	
 - Servers MUST accept absolute URIs.



[.* MUST .*]	
Require that the origin server MUST NOT wait for the request body before it sends a required 100 (Continue) response.



