[.* may .*]
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7230.



[.* may .*]
This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008.



[.* may .*][.* have .* to .*]
The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process.



[.* may .*]
Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.



[.* can .*]
Likewise, servers do not need to be aware of each client's purpose: an HTTP request can be considered in isolation rather than being associated with a specific type of client or a predetermined sequence of application steps.



[.* can .*]
The result is a protocol that can be used effectively in many different contexts and for which implementations can evolve independently over time.



[.* can .*]
HTTP proxies and gateways can provide access to alternative information services by translating their diverse protocols into a hypertext format that can be viewed and manipulated by clients in the same way as HTTP services.



[.* might .*]
However, since multiple clients might act in parallel and perhaps at cross-purposes, we cannot require that such changes be observable beyond the scope of a single response.



[.* has .* to .*]
HTTP was created for the World Wide Web (WWW) architecture and has evolved over time to support the scalability needs of a worldwide hypertext system.



[.* might .*]
The same program might act as a client on some connections and a server on others.



[.* can .*]
The term "origin server" refers to the program that can originate authoritative responses for a given target resource.



[.* might .*]
In the simplest case, this might be accomplished via a single bidirectional connection (===) between the user agent (UA) and the origin server (O).



[.* might .*]
A connection might be used for multiple request/response exchanges, as defined in Section 6.3.



[.* might .*]
In many cases, a user agent is installed or configured to run in the background and save its results for later inspection (or save only a subset of those results that might be interesting or erroneous).



[.* can .*]
The implementation diversity of HTTP means that not all user agents can make interactive suggestions to their user or provide adequate warning for security or privacy concerns.



[.* might .*]
Likewise, requirements that an automated action be confirmed by the user before proceeding might be met via advance configuration choices, run-time options, or simple avoidance of the unsafe action; confirmation does not imply any specific user interface or interruption of normal processing if the user has already made that choice.



[.* might .*]
In some cases, a single intermediary might act as an origin server, proxy, gateway, or tunnel, switching behavior based on the nature of each request.



[.* might .*]
Some HTTP communication options might apply only to the connection with the nearest, non-tunnel neighbor, only to the endpoints of the chain, or to all connections along the chain.



[.* might .*]
Although the diagram is linear, each participant might be engaged in multiple, simultaneous communications.



[.* might .*]
For example, B might be receiving requests from many clients other than A, and/or forwarding requests to servers other than C, at the same time that it is handling A's



[.* might .*]
Likewise, later requests might be sent through a different path of connections, often based on dynamic configuration for load balancing.



[.* might .*]
Some translations are minimal, such as for proxy requests for "http" URIs, whereas other requests might require translation to and from entirely different application-level protocols.



[.* ought .* to .*]
However, an HTTP-to-HTTP gateway that wishes to interoperate with third-party HTTP servers ought to conform to user agent requirements on the gateway's inbound connection.



[.* might .*]
Once active, a tunnel is not considered a party to the HTTP communication, though the tunnel might have been initiated by an HTTP request.



[.* can .*]
There are also intermediaries that can act on lower layers of the network protocol stack, filtering or redirecting HTTP traffic without the knowledge or permission of message senders.



[.* can .*]
HTTP is defined as a stateless protocol, meaning that each request message can be understood in isolation.



[.* have .* to .*]
Some non-standard HTTP extensions (e.g,, [RFC4559]) have been known to violate this requirement, resulting in security and interoperability problems.



[.* has .* to .*]
The effect of a cache is that the request/response chain is shortened if one of the participants along the chain has a cached response applicable to that request.



[.* can .*][.* might .*]
Even when a response is cacheable, there might be additional constraints placed by the client or by the origin server on when that cached response can be used for a particular request.



[.* might .*]
Note, however, that some received protocol elements might not be parsed.



[.* might .*]
forwarding a message might parse a header-field into generic field-name and field-value components, but then forward the header field without further parsing inside the field-value.



[.* might .*]
HTTP does not have specific length limitations for many of its protocol elements because the lengths that might be appropriate will vary widely, depending on the deployment context and purpose of the implementation.



[.* has .* to .*]
Furthermore, what is commonly understood to be a reasonable length for some protocol elements has changed over the course of the past two decades of HTTP use and is expected to continue changing in the future.



[.* might .*]
For example, an origin server might disregard the contents of a received Accept-Encoding header field if inspection of the User-Agent header field indicates a specific implementation version that is known to fail on receipt of certain content codings.



[.* might .*]
For example, a Web browser might wish to transparently recover from a response where the Location header field doesn't parse according to the ABNF, whereas a systems control client might consider any form of error recovery to be dangerous.



[.* can .*]
The minor version advertises the sender's communication capabilities even when the sender is only using a backwards-compatible subset of the protocol, thereby letting the recipient know that more advanced features can be used in response (by servers) or in future requests (by clients).



[.* can .*]
When an HTTP/1.1 message is sent to an HTTP/1.0 recipient [RFC1945] or a recipient whose version is unknown, the HTTP/1.1 message is constructed such that it can be interpreted as a valid HTTP/1.0 message if all of the newer features are ignored.



[.* can .*]
The interpretation of a header field does not change between minor versions of the same major HTTP version, though the default behavior of a recipient in the absence of such a field can change.



[.* can .*]
New header fields can be introduced without changing the protocol version if their defined semantics allow them to be safely ignored by recipients that do not recognize them.



[.* might .*]
HTTP-version might result in communication errors when downstream recipients use the message sender's version to determine what features are safe to use for later communication with that sender.



[.* has .* to .*]
A server SHOULD send a response version equal to the highest version to which the server is conformant that has a major version less than or equal to the one received in the request.



[.* can .*]
A server can send a 505 (HTTP Version Not Supported) response if it wishes, for any reason, to refuse service of the client's major protocol version.



[.* have .* to .*]
The intention of HTTP's versioning design is that the major number will only be incremented if an incompatible message syntax is introduced, and that the minor number will only be incremented when changes made to the protocol have the effect of adding to the message semantics or implying additional capabilities of the sender.



[.* has .* to .*]
However, the minor version was not incremented for the changes introduced between [RFC2068] and [RFC2616], and this revision has specifically avoided any such changes to the protocol.



[.* can .*]
A recipient can assume that a



[.* has .* to .*]
message with a higher minor version, when sent to a recipient that has not yet indicated support for that higher version, is sufficiently backwards-compatible to be safely processed by any implementation of the same major version.



[.* can .*]
An "absolute-path" rule is defined for protocol elements that can contain a non-empty path component.



[.* can .*]
A "partial-URI" rule is defined for protocol elements that can contain a relative URI but not a fragment component.



[.* can .*]
Anyone can mint a URI.



[.* has .* to .*]
What the authority component determines is who has the right to respond authoritatively to requests that target the identified resource.



[.* would .*]
An HTTP service based on some other underlying connection protocol would presumably be identified using a different URI scheme, just as the "https" scheme (below) is used for resources that require an end-to-end secured connection.



[.* might .*]
Other protocols might also be used to provide access to "http" identified resources -- it is only the authoritative interface that is specific to TCP.



[.* might .*]
Some implementations make use of the userinfo component for internal configuration of authentication information, such as within command invocation options, configuration files, or bookmark lists, even though such usage might expose a user identifier or password.



[.* can .*]
However, an extension to HTTP that is defined to apply to entire host domains, such as the Cookie protocol [RFC6265], can allow information set by one service to impact communication with other services within a matching group of host domains.



[.* has .* to .*]
If a message body has been indicated, then it is read as a stream until an amount of octets equal to the message body length is read or the connection is closed.



[.* can .*]
String-based parsers can only be safely used within protocol elements after the element has been extracted from the message, such as within a header field-value after message parsing has delineated the individual fields.



[.* can .*]
An HTTP message can be parsed as a stream for incremental processing or forwarding downstream.



[.* either .* or .*]
A recipient that receives whitespace between the start-line and the first header field MUST either reject the message as invalid or consume each whitespace-preceded line without further processing of it (i.e., ignore the entire line, along with any subsequent lines preceded by whitespace, until a properly formed header field is received or the header section is terminated).



[.* might .*]
The presence of such whitespace in a request might be an attempt to trick a server into ignoring that field or processing the line after it as a new request, either of which might result in a security vulnerability if other implementations within the request chain interpret the same message differently.



[.* might .*]
Likewise, the presence of such whitespace in a response might be ignored by some clients or cause others to cease parsing.



[.* can .*][.* either .* or .*]
An HTTP message can be either a request from client to server or a response from server to client.



[.* either .* or .*]
Syntactically, the two types of message differ only in the start-line, which is either a request-line (for requests) or a status-line (for responses), and in the algorithm for determining the length of the message body (Section 3.3).



[.* could .*]
In theory, a client could receive requests and a server could receive responses, distinguishing them by their different start-line formats, but, in practice, servers are implemented to only expect a request (a response is interpreted as an unknown or invalid request method) and clients are implemented to only expect a response.



[.* can .*]
The request methods defined by this specification can be found in Section 4 of [RFC7231], along with information regarding the HTTP method registry and considerations for defining new methods.



[.* either .* or .*]
Recipients of an invalid request-line SHOULD respond with either a 400 (Bad Request) error or a 301 (Moved Permanently) redirect with the request-target properly encoded.



[.* might .*]
A recipient SHOULD NOT attempt to autocorrect and then process the request without a redirect, since the invalid request-line might be deliberately crafted to bypass security filters along the request chain.



[.* can .*][.* might .*]
New header fields can be defined such that, when they are understood by a recipient, they might override or enhance the interpretation of previously defined header fields, define preconditions on request evaluation, or refine the meaning of responses.



[.* can .*]
However, it is good practice to send header fields that contain control data first, such as Host on requests and Date on responses, so that implementations can decide when not to handle a message as early as possible.



[.* would .*][.* might .*]
header section is received, since later header fields might include conditionals, authentication credentials, or deliberately misleading duplicate header fields that would impact request processing.



[.* either .* or .*]
A sender MUST NOT generate multiple header fields with the same field name in a message unless either the entire field value for that header field is defined as a comma-separated list [i.e., #(values)] or the header field is a well-known exception (as noted below).



[.* might .*]
The OWS rule is used where zero or more linear whitespace octets might appear.



[.* have .* to .*]
In the past, differences in the handling of such whitespace have led to security vulnerabilities in request routing and response handling.



[.* might .*]
A field value might be preceded and/or followed by optional whitespace (OWS); a single SP preceding the field-value is preferred for consistent readability by humans.



[.* could .*]
Historically, HTTP header field values could be extended over multiple lines by preceding each extra line with at least one space or horizontal tab (obs-fold).



[.* has .* to .*]
A sender MUST NOT generate a message that includes line folding (i.e., that has any field-value that contains a match to the obs-fold rule) unless the message is intended for packaging within the message/http media type.



[.* either .* or .*]
A server that receives an obs-fold in a request message that is not within a message/http container MUST either reject the message by sending a 400 (Bad Request), preferably with a representation explaining that obsolete line folding is unacceptable, or replace each received obs-fold with one or more SP octets prior to interpreting the field value or forwarding the message downstream.



[.* either .* or .*]
A proxy or gateway that receives an obs-fold in a response message that is not within a message/http container MUST either discard the message and replace it with a 502 (Bad Gateway) response, preferably with a representation explaining that unacceptable line folding was received, or replace each received obs-fold with one or more SP octets prior to interpreting the field value or forwarding the message downstream.



[.* would .*]
Ignoring such header fields would increase the server's vulnerability to request smuggling attacks (Section 9.5).



[.* can .*]
A client MAY discard or truncate received header fields that are larger than the client wishes to process if the field semantics are such that the dropped value(s) can be safely ignored without changing the message framing or response semantics.



[.* can .*]
Comments can be included in some HTTP header fields by surrounding the comment text with parentheses.



[.* can .*]
The backslash octet ("\") can be used as a single-octet quoting mechanism within quoted-string and comment constructs.



[.* would .*]
), if present, indicate only what their values would have been if the request method had been GET (Section 4.3.1 of [RFC7231]).



[.* might .*]
All other responses do include a message body, although the body might be of zero length.



[.* have .* to .*]
The Transfer-Encoding header field lists the transfer coding names corresponding to the sequence of transfer codings that have been (or will be) applied to the payload body in order to form the message body.



[.* either .* or .*]
If any transfer coding other than chunked is applied to a response payload body, the sender MUST either apply chunked as the final transfer coding or terminate the message by closing the connection.



[.* can .*]
Additional information about the encoding parameters can be provided by other header fields not defined by this specification.



[.* would .*][.* have .* to .*]
Transfer-Encoding MAY be sent in a response to a HEAD request or in a 304 (Not Modified) response (Section 4.1 of [RFC7232]) to a GET request, neither of which includes a message body, to indicate that the origin server would have applied a transfer coding to the message body if the request had been an unconditional GET.



[.* can .*]
This indication is not required, however, because any recipient on the response chain (including the origin server) can remove transfer codings when they are not needed.



[.* might .*]
server will handle HTTP/1.1 (or later) requests; such knowledge might be in the form of specific user configuration or by remembering the version of a prior received response.



[.* can .*]
When a message does not have a Transfer-Encoding header field, a Content-Length header field can provide the anticipated size, as a decimal number of octets, for a potential payload body.



[.* would .*]
A server MAY send a Content-Length header field in a response to a HEAD request (Section 4.3.2 of [RFC7231]); a server MUST NOT send Content-Length in such a response unless its field-value equals the decimal number of octets that would have been sent in the payload body of a response if the same request had used the GET method.



[.* would .*][.* have .* to .*]
unless its field-value equals the decimal number of octets that would have been sent in the payload body of a 200 (OK) response to the same request.



[.* have .* to .*][.* has .* to .*][.* either .* or .*]
If a message is received that has multiple Content-Length header fields with field-values consisting of the same decimal value, or a single Content-Length header field with a field value containing a list of identical decimal values (e.g,, "Content-Length: 42, 42"), indicating that duplicate Content-Length header fields have been generated or combined by an upstream message processor, then the recipient MUST either reject the message as invalid or replace the duplicated field-values with a single valid Content-Length field containing that decimal value prior to determining the message body length or forwarding the message.



[.* might .*]
Such a message might indicate an attempt to perform request smuggling (Section 9.5) or response splitting (Section 9.4) and ought to be handled as an error.



[.* has .* to .*]
Unless a transfer coding other than chunked has been applied, a client that sends a request containing a message body SHOULD use a valid Content-Length header field if the message body length is known in advance, rather than the chunked transfer coding, since some existing services respond to chunked with a 411 (Length Required) status code even though they understand the chunked transfer coding.



[.* can .*]
A user agent that sends a request containing a message body MUST send a valid Content-Length header field if it does not know the server will handle HTTP/1.1 (or later) requests; such knowledge can be in the form of specific user configuration or by remembering the version of a prior received response.



[.* has .* to .*]
If the final response to the last request on a connection has been completely received and there remains additional data to read, a user agent MAY discard the remaining data or attempt to determine if that



[.* might .*]
data belongs as part of the prior response body, which might be the case if the prior message's Content-Length value is incorrect.



[.* would .*]
A client MUST NOT process, cache, or forward such extra data as a separate response, since such behavior would be vulnerable to cache poisoning.



[.* can .*]
A client that receives an incomplete response message, which can occur when a connection is closed prematurely or when decoding a supposedly chunked transfer coding fails, MUST record the message as incomplete.



[.* might .*][.* has .* to .*][.* need .* to .*]
If a response terminates in the middle of the header section (before the empty line is received) and the status code might rely on header fields to convey the full meaning of the response, then the client cannot assume that meaning has been conveyed; the client might need to repeat the request in order to determine what action to take next.



[.* neither .* nor .*]
A response that has neither chunked transfer coding nor Content-Length is terminated by closure of the connection and, thus, is considered complete regardless of the number of message body octets received, provided that the header section was received intact.



[.* might .*]
Older HTTP/1.0 user agent implementations might send an extra CRLF after a POST request as a workaround for some early server applications that failed to read message body content that was not terminated by a line-ending.



[.* can .*]
However, lenient parsing can result in security vulnerabilities if there are multiple recipients of the message and each has its own unique interpretation of robustness (see Section 9.5).



[.* can .*][.* might .*][.* has .* to .*][.* need .* to .*]
Transfer coding names are used to indicate an encoding transformation that has been, can be, or might need to be applied to a payload body in order to ensure "safe transport" through the network.



[.* would .*][.* have .* to .*]
The chunked encoding is specific to each connection and is likely to be removed or recoded by each recipient (including intermediaries) before any higher-level application would have a chance to inspect the extensions.



[.* can .*]
to specialized HTTP services such as "long polling" (where client and server can have shared expectations regarding the use of chunk extensions) or for padding within an end-to-end secured connection.



[.* ought .* to .*]
A server ought to limit the total length of chunk extensions received in a request to an amount reasonable for the services provided, in the same way that it applies length limitations and timeouts for other parts of a message, and generate an appropriate 4xx (Client Error) response if that amount is exceeded.



[.* might .*]
A trailer allows the sender to include additional fields at the end of a chunked message in order to supply metadata that might be dynamically generated while the message body is sent, such as a message integrity check, digital signature, or post-processing status.



[.* might .*]
A recipient MUST ignore (or consider as an error) any fields that are forbidden to be sent in a trailer, since processing them as if they were present in the header section might bypass external security filters.



[.* might .*][.* ought .* to .*]
Without a TE containing "trailers", the server ought to assume that the trailer fields might be silently discarded along the path to the user agent.



[.* can .*]
A process for decoding the chunked transfer coding can be represented in pseudo-code as:



[.* can .*]
The codings defined below can be used to compress the payload of a message.



[.* can .*]
Note that HTTP/1.1 does not define any means to limit the size of a chunked response such that an intermediary can be assured of buffering the entire response.



[.* would .*]
identifier for the "target resource", which a user agent would resolve to its absolute form in order to obtain the "target URI".



[.* can .*]
If the client has a cache [RFC7234] and the request can be satisfied by it, then the request is usually directed there first.



[.* would .*]
directly from the origin server would open (or reuse) a TCP connection to port 80 of the host "www.example.org" and send the lines:



[.* either .* or .*]
The proxy is requested to either service that request from a valid cache, if possible, or make the same request on the client's behalf to either the next inbound proxy server or directly to the origin server indicated by the request-target.



[.* would .*]
An example absolute-form of request-line would be:



[.* has .* to .*]
If a proxy receives an OPTIONS request with an absolute-form of request-target in which the URI has an empty path and no query component, then the last proxy on the request chain MUST send a request-target of "*" when it forwards the request to the indicated origin server.



[.* would .*]
For example, a GET request to the origin server for <http://www.example.org/pub/WWW/> would begin with:



[.* might .*]
A client MUST send a Host header field in an HTTP/1.1 request even if the request-target is in the absolute-form, since this allows the Host information to be forwarded through ancient HTTP/1.0 proxies that might not have implemented Host.



[.* can .*]
The components of the effective request URI, once determined as above, can be combined into absolute-URI form by concatenating the scheme, "://", authority, and combined path and query component.



[.* might .*][.* need .* to .*]
Recipients of an HTTP/1.0 request that lacks a Host header field might need to use heuristics (e.g,, examination of the URI path for something unique to a particular host) in order to guess the effective request URI's authority component.



[.* has .* to .*]
Once the effective request URI has been constructed, an origin server needs to decide whether or not to provide service for that URI via the connection in which the request was received.



[.* might .*]
For example, the request might have been misdirected, deliberately or accidentally, such that the information within a received request-target or Host header field differs from the host or port upon which the connection has been made.



[.* might .*]
If the connection is from a trusted gateway, that inconsistency might be expected; otherwise, it might indicate an attempt to bypass security filters, trick the server into delivering non-public content, or poison a cache.



[.* has .* to .*]
A client that has more than one outstanding request on a connection MUST maintain a list of outstanding requests in the order sent and MUST associate each received response message on that connection to the highest ordered request that has not yet received a final (non-1xx) response.



[.* can .*]
As described in Section 2.3, intermediaries can serve a variety of roles in the processing of HTTP requests and responses.



[.* can .*][.* has .* to .*]
Since an HTTP stream has characteristics similar to a pipe-and-filter architecture, there are no inherent limits to the extent an intermediary can enhance (or interfere) with either direction of the stream.



[.* ought .* to .*]
In general, an intermediary ought to recognize its own server names, including any aliases, local variations, or literal IP addresses, and respond to such requests directly.



[.* can .*]
Via can be used for tracking message forwards, avoiding request loops, and identifying the protocol capabilities of senders along the request/response chain.



[.* can .*][.* might .*]
Hence, the Via field value records the advertised protocol capabilities of the request/response chain such that they remain visible to downstream recipients; this can be useful for determining what backwards-incompatible features might be safe to use in response, or within a later request, as described in Section 2.6.



[.* could .*]
For example, a request message could be sent from an HTTP/1.0 user agent to an internal proxy code-named "fred", which uses HTTP/1.1 to forward the request to a public proxy at p.example.net, which completes the request by forwarding it to the origin server at www.example.com.



[.* would .*]
The request received by www.example.com would then have the following Via header field:



[.* might .*]
However, operational problems might occur when these transformations are applied to payloads intended for critical applications, such as medical imaging or scientific data analysis, particularly when integrity checks or digital signatures are used to ensure that the payload received is identical to the original.



[.* would .*]
An HTTP-to-HTTP proxy is called a "transforming proxy" if it is designed or configured to modify messages in a semantically meaningful way (i.e., modifications, beyond those required by normal HTTP processing, that change the message in a way that would be significant to the original sender or potentially significant to downstream recipients).



[.* might .*]
For example, a transforming proxy might be acting as a shared annotation server (modifying responses to include references to a local annotation database), a malware filter, a format transcoder, or a privacy filter.



[.* can .*][.* has .* to .*]
A proxy that transforms the payload of a 200 (OK) response can further inform downstream recipients that a transformation has been applied by changing the response status code to 203 (Non-Authoritative Information) (Section 6.3.4 of [RFC7231]).



[.* might .*]
For example, the "http" URI scheme (Section 2.7.1) indicates a default connection of TCP over IP, with a default TCP port of 80, but the client might be configured to use a proxy via some other connection, port, or protocol.



[.* might .*]
The connection options do not always correspond to a header field present in the message, since a connection-specific header field might not be needed if there are no parameters associated with a connection option.



[.* has .* to .*]
In contrast, a connection-specific header field that is received without a corresponding connection option usually indicates that the field has been improperly forwarded by an intermediary and ought to be ignored by the recipient.



[.* would .*]
Defining a new connection option essentially reserves that potential field-name for carrying additional information related to the connection option, since it would be unwise for senders to use that field-name for anything else.



[.* either .* or .*]
in either the request or the response header fields indicates that the sender is going to close the connection after the current request/response is complete (Section 6.6).



[.* would .*]
A server MUST read the entire request message body or close the connection after sending its response, since otherwise the remaining data on a persistent connection would be misinterpreted as the next request.



[.* can .*]
Connections can be closed at any time, with or without intention.



[.* ought .* to .*]
Implementations ought to anticipate the need to recover from asynchronous close events.



[.* has .* to .*]
A user agent MUST NOT automatically retry a request with a non- idempotent method unless it has some means to know that the request semantics are actually idempotent, regardless of the method, or some means to detect that the original request was never applied.



[.* can .*]
For example, a user agent that knows (through design or configuration) that a POST request to a given resource is safe can repeat that request automatically.



[.* might .*]
Likewise, a user agent designed specifically to operate on a version control repository might be able to recover from partial failure conditions by checking the target resource revision(s) after a failed connection, reverting or fixing any changes that were partially applied, and then automatically retrying the requests that failed.



[.* can .*][.* might .*]
When retrying pipelined requests after a failed connection (a connection not explicitly closed by the server in its last complete response), a client MUST NOT pipeline immediately after connection establishment, since the first remaining request in the prior pipeline might have caused an error response that can be lost again if multiple requests are sent on a prematurely closed connection (see the TCP reset problem described in Section 6.6).



[.* can .*]
Idempotent methods (Section 4.2.2 of [RFC7231]) are significant to pipelining because they can be automatically retried after a connection failure.



[.* has .* to .*]
A user agent SHOULD NOT pipeline requests after a non-idempotent method, until the final response status code for that method has been received, unless the user agent has a means to detect and recover from partial failure conditions involving the pipelined sequence.



[.* can .*]
An intermediary that receives pipelined requests MAY pipeline those requests when forwarding them inbound, since it can rely on the outbound user agent(s) to determine what requests can be safely pipelined.



[.* can .*][.* have .* to .*]
If the inbound connection fails before receiving a response, the pipelining intermediary MAY attempt to retry a sequence of requests that have yet to receive a response if the requests all have idempotent methods; otherwise, the pipelining intermediary SHOULD forward any received responses and then close the corresponding outbound connection(s) so that the outbound user agent(s) can recover accordingly.



[.* ought .* to .*]
A client ought to limit the number of simultaneous open connections that it maintains to a given server.



[.* can .*]
Furthermore, using multiple connections can cause undesirable side effects in congested networks.



[.* might .*]
Note that a server might reject traffic that it deems abusive or characteristic of a denial-of-service attack, such as an excessive number of open connections from a single client.



[.* might .*]
Proxy servers might make this a higher value since it is likely that the client will be making more connections through the same proxy server.



[.* either .* or .*]
The use of persistent connections places no requirements on the length (or existence) of this timeout for either the client or the server.



[.* might .*][.* have .* to .*][.* has .* to .*]
For example, a client might have started to send a new request at the same time that the server has decided to close the "idle" connection.



[.* can .*]
The latter technique can exacerbate network congestion.



[.* can .*][.* might .*]
If the server receives additional data from the client on a fully closed connection, such as another request that was sent by the client before receiving the server's response, the server's TCP stack will send a reset packet to the client; unfortunately, the reset packet might erase the client's unacknowledged input buffers before they can be read and interpreted by the client's HTTP parser.



[.* might .*]
It is unknown whether the reset problem is exclusive to TCP or might also be found in other transport connection protocols.



[.* had .* to .*][.* has .* to .*]
However, immediately after sending the 101 (Switching Protocols) response, the server is expected to continue responding to the original request as if it had received its equivalent within the new protocol (i.e., the server still has an outstanding request to satisfy after the protocol has been changed, and is expected to do so without requiring the request to be repeated).



[.* can .*]
A server MUST NOT switch protocols unless the received message semantics can be honored by the new protocol; an OPTIONS request can be honored by any protocol.



[.* might .*]
When Upgrade is sent, the sender MUST also send a Connection header field (Section 6.1) that contains an "upgrade" connection option, in order to prevent Upgrade from being accidentally forwarded by intermediaries that might not implement the listed protocols.



[.* could .*]
For compatibility with legacy list rules, a recipient MUST parse and ignore a reasonable number of empty list elements: enough to handle common mistakes by senders that merge values, but not so much that they could be used as a denial-of-service mechanism.



[.* would .*]
In contrast, the following values would be invalid, since at least one non-empty element is required by the example-list production:



[.* might .*]
Furthermore, the header field-name "Close" has been registered as "reserved", since using that name as an HTTP header field might conflict with the "close" connection option of the Connection header field (Section 6.1).



[.* can .*]
The message/http type can be used to enclose a single HTTP request or response message, provided that it obeys the MIME restrictions for all "message" types regarding line length and encodings.



[.* can .*]
If not present, the version can be determined from the first line of the body.



[.* can .*]
present, the type can be determined from the first line of the body.



[.* can .*]
The application/http type can be used to enclose a pipeline of one or more HTTP request or response messages (not intermixed).



[.* can .*]
If not present, the version can be determined from the first line of the body.



[.* can .*]
present, the type can be determined from the first line of the body.



[.* has .* to .*]
HTTP relies on the notion of an authoritative response: a response that has been determined by (or at the direction of) the authority identified within the target URI to be the most appropriate response for that request given the state of the target resource at the time of response message origination.



[.* can .*]
Providing a response from a non-authoritative source, such as a shared cache, is often useful to improve performance and availability, but only to the extent that the source can be trusted or the distrusted response can be safely used.



[.* can .*]
Unfortunately, establishing authority can be difficult.



[.* can .*]
For example, phishing is an attack on the user's perception of authority, where that perception can be misled by presenting similar branding in



[.* can .*]
User agents can reduce the impact of phishing attacks by enabling users to easily inspect a target URI prior to making an action, by prominently distinguishing (or rejecting) userinfo when present, and by not sending stored credentials and cookies when the referring document is from an unknown or untrusted source.



[.* can .*]
When a registered name is used in the authority component, the "http" URI scheme (Section 2.7.1) relies on the user's local name resolution service to determine where it can find authoritative responses.



[.* could .*]
Likewise, the user's choice of server for Domain Name Service (DNS), and the hierarchy of servers from which it obtains resolution results, could impact the authenticity of address mappings; DNS Security Extensions (DNSSEC, [RFC4033]) are one way to improve authenticity.



[.* can .*]
Correctly implementing such verification can be difficult (see [Georgiev]).



[.* can .*]
Compromise of the systems on which the intermediaries run can result in serious security and privacy problems.



[.* might .*][.* have .* to .*]
Intermediaries might have access to security-related information, personal information about individual users and organizations, and proprietary information belonging to users and content providers.



[.* might .*]
A compromised intermediary, or an intermediary implemented or configured without regard to security and privacy considerations, might be used in the commission of a wide range of potential attacks.



[.* need .* to .*]
Implementers need to consider the privacy and security implications of their design and coding decisions, and of the configuration options they provide to operators (especially the default configuration).



[.* can .*]
A server can reject a message that has a request-target that is too long (Section 6.5.12 of [RFC7231]) or a request payload that is too large (Section 6.5.11 of [RFC7231]).



[.* have .* to .*]
Additional status codes related to capacity limits have been defined by extensions to HTTP [RFC6585].



[.* ought .* to .*]
Recipients ought to carefully limit the extent to which they process other protocol elements, including (but not limited to) request methods, response status phrases, header field-names, numeric values, and body chunks.



[.* can .*]
Failure to limit such processing can result in buffer overflows, arithmetic overflows, or increased vulnerability to denial-of-service attacks.



[.* can .*]
This technique can be particularly damaging when the requests pass through a shared cache.



[.* can .*]
Response splitting exploits a vulnerability in servers (usually within an application server) where an attacker can send encoded data within some parameter of the request that is later decoded and echoed within any of the response header fields of the response.



[.* can .*]
The attacker can then make any other request on the same persistent connection and trick the recipients (including intermediaries) into believing that the second half of the split is an authoritative answer to the second request.



[.* might .*]
For example, a parameter within the request-target might be read by an application server and reused within a redirect, resulting in the same parameter being echoed in the Location header field of the response.



[.* can .*]
If the parameter is decoded by the application and not properly encoded when placed in the response field, the attacker can send encoded CRLF octets and other content that will make the application's single response look like two or more responses.



[.* might .*]
Request smuggling ([Linhart]) is a technique that exploits differences in protocol parsing among various recipients to hide additional requests (which might otherwise be blocked or disabled by policy) within an apparently harmless request.



[.* can .*]
Like response splitting, request smuggling can lead to a variety of attacks on HTTP usage.



[.* has .* to .*]
This specification has introduced new requirements on request parsing, particularly with regard to message framing in Section 3.3.3, to reduce the effectiveness of request smuggling.



[.* can .*]
Additional integrity mechanisms, such as hash functions or digital signatures applied to the content, can be selectively added to messages via extensible



[.* can .*]
User agents are encouraged to implement configurable means for detecting and reporting failures of message integrity such that those means can be enabled within environments for which integrity is necessary.



[.* might .*]
Such mechanisms might be selectively enabled via user agent extensions or the presence of message integrity metadata in a response.



[.* ought .* to .*]
At a minimum, user agents ought to provide some indication that allows a user to distinguish between a complete and incomplete response message (Section 3.4) when such verification is desired.



[.* can .*][.* has .* to .*]
HTTP has been specifically designed to be independent of the transport protocol, such that it can be used over many different forms of encrypted connection, with the selection of such transports being identified by the choice of URI scheme or within user agent configuration.



[.* can .*]
The "https" scheme can be used to identify resources that require a confidential connection, as described in Section 2.7.2.



[.* might .*]
A server is in the position to save personal data about a user's requests over time, which might identify their reading patterns or subjects of interest.



[.* can .*]
In particular, log information gathered at an intermediary often contains a history of user agent interaction, across a multitude of sites, that can be traced to individual users.



[.* ought .* to .*]
To minimize the risk of theft or accidental publication, log information ought to be purged of personally identifiable information, including user identifiers, IP addresses, and user-provided query parameters, as soon as that information is no longer necessary to support operational needs for security, auditing, or fraud control.



[.* can .*][.* either .* or .*]
HTTP/1.1 remains compatible with HTTP/1.0 by including more stringent requirements that enable reliable implementations, adding only those features that can either be safely ignored by an HTTP/1.0 recipient or only be sent when communicating with a party advertising conformance with HTTP/1.1.



[.* has .* to .*]
HTTP/1.1 has been designed to make supporting previous versions easy.



[.* ought .* to .*]
A general-purpose HTTP/1.1 server ought to be able to understand any valid request in the format of HTTP/1.0, responding appropriately with an HTTP/1.1 message that only uses features understood (or safely ignored) by HTTP/1.0 clients.



[.* can .*]
Likewise, an HTTP/1.1 client can be expected to understand any valid HTTP/1.0 response.



[.* might .*]
Some clients and servers might wish to be compatible with these previous approaches to persistent connections, by explicitly negotiating for them with a "Connection: keep-alive" request header field.



[.* would .*]
However, some experimental implementations of HTTP/1.0 persistent connections are faulty; for example, if an HTTP/1.0 proxy server doesn't understand Connection, it will erroneously forward that header field to the next inbound server, which would result in a hung connection.



[.* can .*]
Clients are also encouraged to consider the use of Connection: keep-alive in requests carefully; while they can enable persistent connections with HTTP/1.0 servers, clients using them will need to monitor the connection for "hung" requests (which indicate that the client ought stop sending the header field), and this mechanism ought not be used by clients at all when a proxy is being used.



[.* need .* to .*]
Transfer codings need to be decoded prior to forwarding an HTTP message over a MIME-compliant protocol.



[.* has .* to .*]
The HTTP-version ABNF production has been clarified to be case- sensitive.



[.* have .* to .*]
Additionally, version numbers have been restricted to single digits, due to the fact that implementations are known to handle multi-digit version numbers incorrectly.



[.* can .*]
HTTP messages can be (and often are) buffered by implementations; despite it sometimes being available as a stream, HTTP is fundamentally a message-oriented protocol.



[.* have .* to .*]
Minimum supported sizes for various protocol elements have been suggested, to improve interoperability.



[.* has .* to .*]
The algorithm for determining the message body length has been clarified to indicate all of the special cases (e.g,, driven by methods or status codes) that affect it, and that new protocol



[.* have .* to .*]
The segment + query components of RFC 3986 have been used to define the request-target, instead of abs_path from RFC 1808.



